<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋对弈</title>
    <link rel="icon" type="image/png" sizes="96x96" href="me.png">
    <!-- 将 Tailwind CDN 脚本放在 tailwind.config 定义之前 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#8B5A2B', // 深棕色
                        secondary: '#D2B48C', // 浅棕色
                        accent: '#FF69B4', // 亮粉色
                        board: '#DEB887', // 棋盘色
                        opponent: '#FFFFFF', // 白棋
                        player: '#000000', // 黑棋
                        highlight: '#FF69B4' // 高亮色
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <style type="text/tailwindcss">
        @layer utilities {
            .board-shadow { box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25); }
            .piece-shadow { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }
            .thinking-indicator { animation: thinking 1.5s infinite; }
            @keyframes thinking {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }

            /* 模态框样式 */
            .modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(5px);
                -webkit-backdrop-filter: blur(5px);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .modal-content {
                background-color: #fefefe;
                padding: 0; /* 移除内边距，由内部面板控制 */
                border: none;
                width: 90%;
                max-width: 600px; /* 增大宽度以容纳两个面板 */
                border-radius: 12px;
                text-align: center;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                position: relative;
                animation: fadeInScale 0.3s ease-out;
                overflow: hidden; /* 隐藏溢出的动画 */
            }
            @keyframes fadeInScale {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
            
            /* 胜负结果面板 */
            .result-panel-container {
                display: flex;
                width: 100%;
            }
            .result-panel {
                width: 50%;
                padding: 40px 20px;
                position: relative;
                overflow: hidden; /* 确保动画在面板内 */
            }
            .result-panel.winner {
                background-color: #f0fff0; /* 淡绿色背景 */
            }
            .result-panel.loser {
                background-color: #f5f5f5; /* 淡灰色背景 */
            }
            .result-panel h3 {
                font-size: 1.8rem;
                font-weight: bold;
                margin-bottom: 10px;
            }
            .result-panel p {
                font-size: 1.2rem;
            }
            .winner h3 { color: #228B22; } /* 森林绿 */
            .loser h3 { color: #808080; } /* 灰色 */

            /* 模态框按钮 */
            .modal-buttons {
                padding: 20px;
                background-color: #fff;
                border-top: 1px solid #eee;
                display: flex;
                justify-content: center;
                gap: 15px;
            }

            /* 胜利彩色碎片动画 */
            .confetti-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            .confetti {
                position: absolute;
                width: 10px;
                height: 10px;
                background-color: #f00;
                opacity: 0;
                animation: confetti-fall 3s ease-out forwards;
            }
            @keyframes confetti-fall {
                0% { transform: translateY(-100%) rotateZ(0deg); opacity: 1; }
                100% { transform: translateY(150%) rotateZ(720deg); opacity: 0; }
            }

            /* 失败乌云动画 */
            .clouds-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            .cloud {
                position: absolute;
                background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgNjAiPjxwYXRoIGZpbGw9IiM5RTlFOUUiIGQ9Ik05NC40IDQyLjRjLTMuOC0xNS4xLTE3LjgtMjYtMzQuMi0yNi0xMC4zIDAtMTkuNSA0LjYtMjUuOSAxMS45QzMwLjYgMjQuMyAyMy43IDIyIDE2IDIyIDcuMiAyMiAwIDI5LjIgMCAzOC4xYzAgMS4zIDAuMiAyLjUgMC40IDMuN0M2LjYgNDIgMTMuMiA0MiAxMyuMiA0MmhxMS4zYzQuNC0xMy4xIDE3LjMtMjIuNCAzMS41LTIyLjQgMTMuMSAwIDI0LjUgOC4zIDMwLjEgMjAuMmwxMi43YzIuOSAwIDUuNi0xLjMgNy40LTMuNCAxLjItMS40IDEuOC0zLjEgMS44LTQuN3oiLz48L3N2Zz4=');
                background-repeat: no-repeat;
                background-size: contain;
                width: 120px;
                height: 72px;
                opacity: 0;
                animation: cloud-drift 10s linear forwards;
            }
            @keyframes cloud-drift {
                0% { transform: translateX(-100%); opacity: 0; }
                10% { opacity: 0.7; }
                90% { opacity: 0.7; }
                100% { transform: translateX(150%); opacity: 0; }
            }

            /* 棋盘遮罩 */
            #board-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(128, 128, 128, 0.5);
                z-index: 10;
                display: none; /* 默认隐藏 */
                border-radius: 0.5rem; /* 保持和棋盘容器一致的圆角 */
            }

            /* 响应式棋盘容器 */
            #board-container {
                width: 100%;
                padding-top: 100%;
                position: relative;
            }
            #board {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }

            /* 游戏日志样式 */
            .game-log-container {
                max-height: 200px; /* Limit height for scrollability */
                overflow-y: auto; /* Enable vertical scrolling */
                background-color: #fefee0; /* Light yellow background */
                border: 1px solid #e0e0b0; /* Matching border */
                border-radius: 8px;
                padding: 1rem;
                font-size: 0.9rem;
                color: #5a4a3a;
                margin-top: 1.5rem; /* Space from the board */
            }
            .game-log-container p {
                margin-bottom: 0.3rem;
                line-height: 1.4;
            }
            .game-log-container p:last-child {
                margin-bottom: 0;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 font-sans text-gray-800 bg-secondary">
    <div class="max-w-5xl w-full mx-auto rounded-xl shadow-2xl overflow-hidden border border-gray-100 bg-white/60 backdrop-blur-sm">
        <header class="bg-primary text-white p-6 md:p-8 text-center rounded-t-xl">
            <h1 class="text-[clamp(2rem,6vw,3rem)] font-extrabold tracking-wide drop-shadow-md">五子棋对弈</h1>
            <p class="mt-2 text-secondary/90 text-[clamp(1rem,2.5vw,1.3rem)] font-light">与人工智能“开元”一决高下</p>
        </header>

        <main class="p-6 md:p-10 flex flex-col md:flex-row gap-8">
            <!-- 游戏信息和控制区 -->
            <div class="w-full md:w-1/3 flex flex-col gap-6">
                <div class="bg-white/80 p-5 rounded-lg shadow-lg border border-gray-200">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center"><i class="fa fa-info-circle text-primary mr-3 text-2xl"></i>游戏信息</h2>
                    <div class="space-y-4 text-base">
                        <div>
                            <p class="text-gray-600 text-sm">当前回合</p>
                            <div id="current-player" class="flex items-center mt-1">
                                <div id="player-indicator" class="w-6 h-6 rounded-full border-2 border-gray-300 mr-2 piece-shadow"></div>
                                <span id="player-text" class="font-semibold text-lg"></span>
                            </div>
                        </div>
                        <div>
                            <p class="text-gray-600 text-sm">游戏状态</p>
                            <p id="game-status" class="mt-1 font-semibold text-lg text-gray-800">游戏进行中</p>
                        </div>
                    </div>
                </div>

                <div class="bg-white/80 p-5 rounded-lg shadow-lg border border-gray-200">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center"><i class="fa fa-cogs text-primary mr-3 text-2xl"></i>游戏控制</h2>
                    <div class="space-y-3">
                        <button id="new-game" class="w-full bg-primary hover:bg-primary/90 text-white py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-refresh mr-2"></i>开始新局</button>
                        <button id="undo" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-undo mr-2"></i>悔棋</button>
                        <button id="difficulty-toggle" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-bolt mr-2"></i>难度: <span id="difficulty-text">一般</span></button>
                        <button id="mode-toggle" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-users mr-2"></i>模式: <span id="mode-text">玩家 vs 开元</span></button>
                        <button id="music-toggle" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-music mr-2"></i>音乐: <span id="music-text">关闭</span></button>
                        <button id="close-game" class="w-full bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center font-semibold text-lg shadow-md hover:shadow-lg"><i class="fa fa-power-off mr-2"></i>关闭游戏</button>
                    </div>
                </div>
            </div>

            <!-- 棋盘区域 -->
            <div class="w-full md:w-2/3 flex flex-col items-center">
                <div class="relative w-full max-w-lg mx-auto">
                    <div id="board-container" class="board-shadow rounded-lg overflow-hidden relative border-4 border-primary">
                        <canvas id="board" class="bg-board"></canvas>
                        <div id="board-overlay"></div>
                        <div id="thinking" class="absolute inset-0 bg-black/50 flex items-center justify-center hidden rounded-lg">
                            <div class="bg-white p-6 rounded-lg text-center shadow-xl">
                                <div class="flex justify-center mb-3">
                                    <div class="w-4 h-4 rounded-full bg-primary mx-1 thinking-indicator"></div>
                                    <div class="w-4 h-4 rounded-full bg-primary mx-1 thinking-indicator" style="animation-delay: 0.3s"></div>
                                    <div class="w-4 h-4 rounded-full bg-primary mx-1 thinking-indicator" style="animation-delay: 0.6s"></div>
                                </div>
                                <p class="text-primary font-bold text-lg">开元正在思考...</p>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 游戏日志记录区域 -->
                <div class="w-full max-w-lg mx-auto mt-6">
                    <h3 class="text-lg font-bold text-gray-800 mb-2">游戏日志记录</h3>
                    <div id="game-log" class="game-log-container">
                        <!-- Log messages will be appended here -->
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- 胜负提示模态框 -->
    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <div id="result-container-normal" class="result-panel-container">
                <!-- 获胜方 -->
                <div id="winner-panel" class="result-panel winner">
                    <div class="confetti-container"></div>
                    <h3 id="winner-title">胜利</h3>
                    <p id="winner-name"></p>
                </div>
                <!-- 失败方 -->
                <div id="loser-panel" class="result-panel loser">
                    <div class="clouds-container"></div>
                    <h3 id="loser-title">惜败</h3>
                    <p id="loser-name"></p>
                </div>
            </div>
             <div id="result-container-draw" class="result-panel-container" style="display: none;">
                <div class="result-panel" style="width:100%; background-color: #f8f8f8;">
                    <h3>平局</h3>
                    <p>棋逢对手，再战一局！</p>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="new-game-modal" class="bg-primary hover:bg-primary/90 text-white py-2 px-6 rounded-lg transition-all duration-300 font-semibold shadow-md">开始新局</button>
                <button id="close-modal" class="bg-gray-400 hover:bg-gray-500 text-white py-2 px-6 rounded-lg transition-all duration-300 font-semibold shadow-md">关闭提示</button>
            </div>
        </div>
    </div>

    <audio id="music" src="jasmine.mp3" loop></audio>

    <footer class="mt-8 text-center text-gray-600 text-sm">
        <p>五子棋游戏 &copy; 2025 | Designed by 开元 </p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game Constants
            const BOARD_SIZE = 15;
            const PIECE_SIZE_RATIO = 0.8;
            const BOARD_PADDING_RATIO = 1;

            // DOM Elements
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const boardContainer = document.getElementById('board-container');
            const boardOverlay = document.getElementById('board-overlay');
            const currentPlayerIndicator = document.getElementById('player-indicator');
            const currentPlayerText = document.getElementById('player-text');
            const gameStatus = document.getElementById('game-status');
            const newGameBtn = document.getElementById('new-game');
            const undoBtn = document.getElementById('undo');
            const difficultyToggle = document.getElementById('difficulty-toggle');
            const difficultyText = document.getElementById('difficulty-text');
            const thinkingIndicator = document.getElementById('thinking');
            const modeToggle = document.getElementById('mode-toggle');
            const modeText = document.getElementById('mode-text');
            const musicToggle = document.getElementById('music-toggle');
            const musicText = document.getElementById('music-text');
            const closeGameBtn = document.getElementById('close-game');
            const music = document.getElementById('music');
            const gameLog = document.getElementById('game-log'); // New: Game Log element
            
            // Modal Elements
            const winnerModal = document.getElementById('winner-modal');
            const resultContainerNormal = document.getElementById('result-container-normal');
            const resultContainerDraw = document.getElementById('result-container-draw');
            const winnerPanel = document.getElementById('winner-panel');
            const loserPanel = document.getElementById('loser-panel');
            const winnerName = document.getElementById('winner-name');
            const loserName = document.getElementById('loser-name');
            const newGameModalBtn = document.getElementById('new-game-modal');
            const closeModalBtn = document.getElementById('close-modal');

            // Game State
            let gameBoard;
            let humanPlayer;
            let aiPlayer;
            let currentPlayer;
            let gameOver;
            let moveHistory;
            let lastMovePosition;
            let actualCellSize, actualPieceSize, actualBoardPadding;

            // Game Settings
            let gameMode = 1; // 1: Player vs AI, 2: Player vs Player
            let difficulty = 2; // 1: Easy, 2: Normal, 3: Hard
            let isFirstPlayerBlack = true; // Tracks if Player 1 (or human) is black

            // AI evaluation patterns
            const patterns = {
                FIVE: 1000000,
                LIVE_FOUR: 50000,
                DEAD_FOUR: 5000,
                LIVE_THREE: 5000,
                DEAD_THREE: 500,
                LIVE_TWO: 100,
                DEAD_TWO: 10,
            };

            // Function to log messages to the game log area
            function logMessage(message) {
                const p = document.createElement('p');
                p.textContent = message;
                gameLog.appendChild(p);
                // Scroll to the bottom to show the latest message
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            function setCanvasSize() {
                const containerWidth = boardContainer.offsetWidth;
                actualCellSize = Math.floor(containerWidth / (BOARD_SIZE - 1 + BOARD_PADDING_RATIO * 2));
                actualPieceSize = actualCellSize * PIECE_SIZE_RATIO;
                actualBoardPadding = actualCellSize * BOARD_PADDING_RATIO;
                const size = (BOARD_SIZE - 1) * actualCellSize + actualBoardPadding * 2;
                canvas.width = size;
                canvas.height = size;
                drawBoard();
            }

            function resetBoardAndState() {
                gameBoard = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
                gameOver = false;
                moveHistory = [];
                lastMovePosition = null;
                boardOverlay.style.display = 'none';
                winnerModal.style.display = 'none';
                currentPlayer = 1; // Black always starts
                gameLog.innerHTML = ''; // Clear game log on new game
                logMessage("游戏开始！");
            }

            function startGame() {
                resetBoardAndState();

                if (gameMode === 1) { // Setup for PvE
                    humanPlayer = isFirstPlayerBlack ? 1 : 2;
                    aiPlayer = isFirstPlayerBlack ? 2 : 1;
                }

                updateGameStatus();
                setCanvasSize();

                if (gameMode === 1 && currentPlayer === aiPlayer) {
                    logMessage("开元先行。");
                    aiTurn();
                } else if (gameMode === 1) {
                    logMessage("玩家先行。");
                } else {
                    logMessage("玩家1先行。");
                }
            }

            function drawBoard() {
                const size = canvas.width;
                ctx.clearRect(0, 0, size, size);
                ctx.fillStyle = tailwind.config.theme.extend.colors.board;
                ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = tailwind.config.theme.extend.colors.primary;
                ctx.lineWidth = 1;

                for (let i = 0; i < BOARD_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(actualBoardPadding, actualBoardPadding + i * actualCellSize);
                    ctx.lineTo(size - actualBoardPadding, actualBoardPadding + i * actualCellSize);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(actualBoardPadding + i * actualCellSize, actualBoardPadding);
                    ctx.lineTo(actualBoardPadding + i * actualCellSize, size - actualBoardPadding);
                    ctx.stroke();
                }

                const starPoints = [{x: 3, y: 3}, {x: 3, y: 11}, {x: 7, y: 7}, {x: 11, y: 3}, {x: 11, y: 11}];
                starPoints.forEach(p => drawStarPoint(p.x, p.y));

                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] !== 0) {
                            drawPiece(i, j, gameBoard[i][j] === 1 ? 'black' : 'white');
                        }
                    }
                }

                if (lastMovePosition) {
                    drawLastMoveMarker(lastMovePosition.x, lastMovePosition.y);
                }
            }
            
            function drawStarPoint(x, y) {
                const centerX = actualBoardPadding + x * actualCellSize;
                const centerY = actualBoardPadding + y * actualCellSize;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
                ctx.fillStyle = tailwind.config.theme.extend.colors.primary;
                ctx.fill();
            }

            function drawPiece(x, y, color) {
                const centerX = actualBoardPadding + x * actualCellSize;
                const centerY = actualBoardPadding + y * actualCellSize;
                ctx.beginPath();
                ctx.arc(centerX, centerY, actualPieceSize / 2, 0, 2 * Math.PI);
                const gradient = ctx.createRadialGradient(
                    centerX - actualPieceSize / 5, centerY - actualPieceSize / 5, actualPieceSize / 10,
                    centerX, centerY, actualPieceSize / 2
                );
                if (color === 'white') {
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(1, '#E6E6E6');
                    ctx.strokeStyle = '#D9D9D9';
                } else {
                    gradient.addColorStop(0, '#404040');
                    gradient.addColorStop(1, '#000000');
                    ctx.strokeStyle = '#333333';
                }
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            function drawLastMoveMarker(x, y) {
                const centerX = actualBoardPadding + x * actualCellSize;
                const centerY = actualBoardPadding + y * actualCellSize;
                ctx.beginPath();
                ctx.arc(centerX, centerY, actualPieceSize / 4, 0, 2 * Math.PI);
                ctx.fillStyle = tailwind.config.theme.extend.colors.accent;
                ctx.fill();
            }

            function handlePlayerMove(x, y) {
                if (gameOver || gameBoard[x][y] !== 0) return;
                
                if (gameMode === 1 && currentPlayer === aiPlayer) return;

                gameBoard[x][y] = currentPlayer;
                moveHistory.push({ x, y, player: currentPlayer });
                lastMovePosition = { x, y };
                drawBoard();

                const playerColor = currentPlayer === 1 ? '黑棋' : '白棋';
                const playerName = (gameMode === 1) ? (currentPlayer === humanPlayer ? '玩家' : '开元') : (currentPlayer === (isFirstPlayerBlack ? 1 : 2) ? '玩家 1' : '玩家 2');
                logMessage(`${playerName} (${playerColor}) 落子于 (${x}, ${y})`);

                if (checkWin(x, y, currentPlayer)) {
                    endGame(currentPlayer);
                    return;
                }
                if (isBoardFull()) {
                    endGame(0); // Draw
                    return;
                }

                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                updateGameStatus();

                if (gameMode === 1 && currentPlayer === aiPlayer) {
                    aiTurn();
                }
            }
            
            function aiTurn() {
                thinkingIndicator.classList.remove('hidden');
                setTimeout(() => {
                    const move = makeAiMove();
                    thinkingIndicator.classList.add('hidden');
                    if (move) {
                        gameBoard[move.x][move.y] = aiPlayer;
                        moveHistory.push({ x: move.x, y: move.y, player: aiPlayer });
                        lastMovePosition = { x: move.x, y: move.y };
                        drawBoard();

                        const playerColor = aiPlayer === 1 ? '黑棋' : '白棋';
                        logMessage(`开元 (${playerColor}) 落子于 (${move.x}, ${move.y})`);

                        if (checkWin(move.x, move.y, aiPlayer)) {
                            endGame(aiPlayer);
                            return;
                        }
                        if (isBoardFull()) {
                            endGame(0);
                            return;
                        }

                        currentPlayer = humanPlayer;
                        updateGameStatus();
                    }
                }, 500 + Math.random() * 500);
            }
            
            function findWinningMove(player, board) {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                            board[i][j] = player;
                            if (checkWin(i, j, player)) {
                                board[i][j] = 0;
                                return { x: i, y: j };
                            }
                            board[i][j] = 0;
                        }
                    }
                }
                return null;
            }

            function makeAiMove() {
                let winningMove = findWinningMove(aiPlayer, gameBoard);
                if (winningMove) return winningMove;

                let blockingMove = findWinningMove(humanPlayer, gameBoard);
                if (blockingMove) return blockingMove;

                if (difficulty === 1) return makeRandomMove();
                
                const searchDepth = difficulty === 2 ? 2 : 4;
                let bestScore = -Infinity;
                let bestMove = null;
                
                const candidateMoves = getSortedCandidateMoves(gameBoard);

                for (const move of candidateMoves) {
                    const { x, y } = move;
                    gameBoard[x][y] = aiPlayer;
                    let score = minimax(gameBoard, searchDepth - 1, -Infinity, Infinity, false);
                    gameBoard[x][y] = 0;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { x, y };
                    }
                }
                return bestMove || makeRandomMove();
            }

            function minimax(board, depth, alpha, beta, isMaximizing) {
                let winner = getWinner(board);
                if (winner !== 0) {
                    return (winner === aiPlayer ? patterns.FIVE : -patterns.FIVE) * (depth + 1);
                }
                if (depth === 0 || isBoardFull(board)) {
                    return evaluateBoard(board);
                }

                const player = isMaximizing ? aiPlayer : humanPlayer;
                let bestValue = isMaximizing ? -Infinity : Infinity;
                const candidateMoves = getSortedCandidateMoves(board);

                for (const move of candidateMoves) {
                    const { x, y } = move;
                    board[x][y] = player;
                    const value = minimax(board, depth - 1, alpha, beta, !isMaximizing);
                    board[x][y] = 0;

                    if (isMaximizing) {
                        bestValue = Math.max(bestValue, value);
                        alpha = Math.max(alpha, value);
                    } else {
                        bestValue = Math.min(bestValue, value);
                        beta = Math.min(beta, value);
                    }
                    if (beta <= alpha) break;
                }
                return bestValue;
            }

            function evaluateBoard(board) {
                let aiScore = 0;
                let humanScore = 0;
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                           aiScore += evaluatePosition(i, j, aiPlayer, board);
                           humanScore += evaluatePosition(i, j, humanPlayer, board);
                        }
                    }
                }
                return aiScore - humanScore * 1.5;
            }

            function evaluatePosition(x, y, player, board) {
                let score = 0;
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
                for (const [dx, dy] of directions) {
                    score += getLineScore(x, y, dx, dy, player, board);
                }
                return score;
            }

            function getLineScore(x, y, dx, dy, player, board) {
                let count = 0;
                let openEnds = 0;
                const opponent = player === 1 ? 2 : 1;

                for (let i = 1; i < 5; i++) {
                    const nx = x + i * dx, ny = y + i * dy;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || board[nx][ny] === opponent) break;
                    if (board[nx][ny] === 0) { openEnds++; break; }
                    if (board[nx][ny] === player) count++;
                }

                for (let i = 1; i < 5; i++) {
                    const nx = x - i * dx, ny = y - i * dy;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || board[nx][ny] === opponent) break;
                    if (board[nx][ny] === 0) { openEnds++; break; }
                    if (board[nx][ny] === player) count++;
                }

                if (count >= 4) return patterns.FIVE;
                if (count === 3 && openEnds === 2) return patterns.LIVE_FOUR;
                if (count === 3 && openEnds === 1) return patterns.DEAD_FOUR;
                if (count === 2 && openEnds === 2) return patterns.LIVE_THREE;
                if (count === 2 && openEnds === 1) return patterns.DEAD_THREE;
                if (count === 1 && openEnds === 2) return patterns.LIVE_TWO;
                if (count === 1 && openEnds === 1) return patterns.DEAD_TWO;
                
                return 0;
            }
            
            function getSortedCandidateMoves(board) {
                const moves = [];
                const seen = new Set();
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 0 && hasAdjacentPieces(i, j, 2, board)) {
                            moves.push({ x: i, y: j });
                        }
                    }
                }
                if (moves.length === 0) {
                    return [{x: 7, y: 7}];
                }
                return moves;
            }

            function hasAdjacentPieces(x, y, radius, board) {
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        if (i === 0 && j === 0) continue;
                        const nx = x + i, ny = y + j;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            function makeRandomMove() {
                const availableMoves = [];
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) availableMoves.push({ x: i, y: j });
                    }
                }
                return availableMoves.length > 0 ? availableMoves[Math.floor(Math.random() * availableMoves.length)] : null;
            }

            function checkWin(x, y, player) {
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
                for (const [dx, dy] of directions) {
                    let count = 1;
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx, ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && gameBoard[nx][ny] === player) count++; else break;
                    }
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx, ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && gameBoard[nx][ny] === player) count++; else break;
                    }
                    if (count >= 5) return true;
                }
                return false;
            }
            
            function getWinner(board) {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] !== 0 && checkWin(i, j, board[i][j])) return board[i][j];
                    }
                }
                return 0;
            }

            function isBoardFull(board = gameBoard) {
                return board.every(row => row.every(cell => cell !== 0));
            }

            function endGame(winner) {
                gameOver = true;
                let winnerText, loserText;

                if (winner === 0) {
                    gameStatus.textContent = "平局！";
                    logMessage("游戏结束：平局！");
                    showWinnerModal(null, null, true);
                    return;
                }

                if (gameMode === 1) {
                    winnerText = (winner === humanPlayer) ? "玩家" : "开元";
                    loserText = (winner === humanPlayer) ? "开元" : "玩家";
                } else {
                    winnerText = (winner === (isFirstPlayerBlack ? 1 : 2)) ? "玩家 1" : "玩家 2";
                    loserText = (winner === (isFirstPlayerBlack ? 1 : 2)) ? "玩家 2" : "玩家 1";
                }
                
                gameStatus.textContent = `${winnerText} 获胜!`;
                logMessage(`游戏结束：${winnerText} 获胜！`);
                showWinnerModal(winnerText, loserText);
            }

            function updateGameStatus() {
                if (gameOver) return;
                let currentPlayerName;
                if (gameMode === 1) {
                    currentPlayerName = (currentPlayer === humanPlayer) ? "玩家" : "开元";
                } else {
                    currentPlayerName = (currentPlayer === (isFirstPlayerBlack ? 1 : 2)) ? "玩家 1" : "玩家 2";
                }
                
                const colorName = currentPlayer === 1 ? '黑棋' : '白棋';
                const colorClass = currentPlayer === 1 ? 'bg-player' : 'bg-opponent';
                
                currentPlayerIndicator.className = `w-6 h-6 rounded-full ${colorClass} border-2 border-gray-300 mr-2 piece-shadow`;
                currentPlayerText.textContent = `${currentPlayerName} (${colorName})`;
                gameStatus.textContent = "游戏进行中";
            }
            
            function updateDifficultyUI() {
                difficultyText.textContent = { 1: '简单', 2: '一般', 3: '困难' }[difficulty];
                logMessage(`难度设置为：${difficultyText.textContent}`);
            }

            function updateModeUI() {
                modeText.textContent = gameMode === 1 ? '玩家 vs 开元' : '玩家 vs 玩家';
                difficultyToggle.style.display = gameMode === 1 ? 'flex' : 'none';
                logMessage(`游戏模式切换为：${modeText.textContent}`);
            }

            function showWinnerModal(winner, loser, isDraw = false) {
                resultContainerNormal.style.display = isDraw ? 'none' : 'flex';
                resultContainerDraw.style.display = isDraw ? 'block' : 'none';
                
                if (!isDraw) {
                    winnerName.textContent = winner;
                    loserName.textContent = loser;
                    
                    winnerPanel.querySelector('.confetti-container').innerHTML = '';
                    loserPanel.querySelector('.clouds-container').innerHTML = '';

                    showConfetti(winnerPanel.querySelector('.confetti-container'));
                    showClouds(loserPanel.querySelector('.clouds-container'));
                }
                winnerModal.style.display = 'flex';
            }

            function showConfetti(container) {
                const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.classList.add('confetti');
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = `${Math.random() * 2}s`;
                    container.appendChild(confetti);
                }
            }

            function showClouds(container) {
                const cloud = document.createElement('div');
                cloud.classList.add('cloud');
                container.appendChild(cloud);
            }

            // Event Listeners
            canvas.addEventListener('click', (event) => {
                if (gameOver) return;
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = Math.round((clickX * scaleX - actualBoardPadding) / actualCellSize);
                const y = Math.round((clickY * scaleY - actualBoardPadding) / actualCellSize);

                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                    handlePlayerMove(x, y);
                }
            });

            function startNewRound() {
                isFirstPlayerBlack = !isFirstPlayerBlack;
                startGame();
                logMessage("开始新一局游戏。");
            }

            newGameBtn.addEventListener('click', startNewRound);
            newGameModalBtn.addEventListener('click', startNewRound);
            
            closeModalBtn.addEventListener('click', () => {
                winnerModal.style.display = 'none';
                boardOverlay.style.display = 'block';
                logMessage("关闭结果提示。");
            });
            
            closeGameBtn.addEventListener('click', () => {
                document.body.innerHTML = '<h1 style="text-align:center; margin-top: 50px;">感谢游玩，再见！</h1>';
                logMessage("游戏已关闭。");
            });

            undoBtn.addEventListener('click', () => {
                if (gameOver || moveHistory.length === 0) return;

                if (gameMode === 1) { // Player vs AI
                    if (currentPlayer === humanPlayer && moveHistory.length >= 2) {
                        moveHistory.pop(); // AI move
                        moveHistory.pop(); // Player move
                        logMessage("悔棋：撤销玩家和开元各一步。");
                        // State will be restored below
                    } else if (currentPlayer === aiPlayer && moveHistory.length >= 1) {
                         moveHistory.pop(); // AI move
                         logMessage("悔棋：撤销开元一步。");
                    }
                    else {
                        return; // Cannot undo
                    }
                } else { // Player vs Player
                    moveHistory.pop();
                    logMessage("悔棋：撤销一步。");
                }

                // Rebuild board from history
                const history = [...moveHistory];
                resetBoardAndState();
                moveHistory = history;
                
                moveHistory.forEach(move => {
                    gameBoard[move.x][move.y] = move.player;
                });

                if (moveHistory.length > 0) {
                    lastMovePosition = moveHistory[moveHistory.length - 1];
                    const lastPlayer = lastMovePosition.player;
                    currentPlayer = lastPlayer === 1 ? 2 : 1;
                } else {
                    lastMovePosition = null;
                    currentPlayer = 1;
                }
                
                if (gameMode === 1) currentPlayer = humanPlayer;

                drawBoard();
                updateGameStatus();
            });

            difficultyToggle.addEventListener('click', () => {
                difficulty = (difficulty % 3) + 1;
                updateDifficultyUI();
            });

            modeToggle.addEventListener('click', () => {
                gameMode = gameMode === 1 ? 2 : 1;
                isFirstPlayerBlack = true; // Reset starting player on mode change
                updateModeUI();
                startGame();
            });
            
            musicToggle.addEventListener('click', () => {
                if (music.paused) {
                    music.play().catch(e => console.error("Music playback failed:", e));
                    musicText.textContent = '开启';
                    logMessage("背景音乐：开启");
                } else {
                    music.pause();
                    musicText.textContent = '关闭';
                    logMessage("背景音乐：关闭");
                }
            });

            window.addEventListener('resize', setCanvasSize);
            
            // Initial game start
            updateDifficultyUI();
            updateModeUI();
            startGame();
        });
    </script>
</body>
</html>
