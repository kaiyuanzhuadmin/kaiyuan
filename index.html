<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>五子棋对弈</title>
    <link rel="icon" type="image/png" sizes="96x96" href="me.png">
    <style>
        /* 本地化样式，替代Tailwind CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'SimHei', Arial, sans-serif;
            background: linear-gradient(135deg, #fef7ed 0%, #fed7aa 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0.5rem;
            margin: 0;
            /* Prevent text selection on touch devices */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation; /* Allow touch actions like pan/zoom */
        }
        
        @media (min-width: 768px) {
            body {
                justify-content: center;
                padding: 1rem;
            }
        }
        
        .container {
            max-width: 80rem;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            min-height: calc(100vh - 1rem);
            display: flex;
            flex-direction: column;
        }
        
        @media (min-width: 768px) {
            .container {
                border-radius: 0.75rem;
                min-height: auto;
            }
        }
        
        .header {
            background: #8B5A2B;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        @media (min-width: 768px) {
            .header {
                padding: 2rem;
            }
        }
        
        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: bold;
            letter-spacing: 0.025em;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            color: #D2B48C;
            font-size: clamp(0.9rem, 2vw, 1.2rem);
        }
        
        .main {
            padding: 1rem;
            display: flex;
            gap: 1rem;
            flex-direction: column;
        }
        
        @media (min-width: 768px) {
            .main {
                padding: 2rem;
                flex-direction: row;
                gap: 2rem;
            }
        }
        
        .sidebar {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        @media (min-width: 768px) {
            .sidebar {
                flex: 1;
                min-width: 280px;
                gap: 1.5rem;
            }
        }
        
        .board-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }
        
        @media (min-width: 768px) {
            .board-area {
                flex: 2;
                padding: 0 1rem;
            }
        }
        
        .info-card {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        @media (min-width: 768px) {
            .info-card {
                padding: 1.25rem;
            }
        }
        
        .info-card h2 {
            font-size: 1.1rem;
            font-weight: bold;
            color: #374151;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }
        
        @media (min-width: 768px) {
            .info-card h2 {
                font-size: 1.25rem;
                margin-bottom: 1rem;
            }
        }
        
        .icon {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
            color: #8B5A2B;
        }
        
        .info-item {
            margin-bottom: 1rem;
        }
        
        .info-item:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: #6b7280;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .player-indicator {
            display: flex;
            align-items: center;
            margin-top: 0.25rem;
        }
        
        .piece {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            margin-right: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .piece.black {
            background: #000000;
            border: 2px solid #374151;
        }
        
        .piece.white {
            background: #ffffff;
            border: 2px solid #d1d5db;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .input-group input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            color: #374151;
            width: 100%;
        }

        .input-group input:focus {
            outline: none;
            border-color: #8B5A2B;
            box-shadow: 0 0 0 2px rgba(139, 90, 43, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #8B5A2B;
            color: white;
        }
        
        .btn-primary:hover {
            background: #7c4f26;
        }
        
        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }
        
        .btn-secondary:hover {
            background: #d1d5db;
        }
        
        .board-container {
            position: relative;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            width: fit-content;
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            /* Ensure the container is touch-action compatible for gestures */
            touch-action: none; 
        }
        
        @media (max-width: 480px) {
            .board-container {
                margin: 0 auto;
                border-radius: 0.25rem;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            }
        }
        
        #board {
            background: #DEB887;
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .thinking-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .thinking-content {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        
        .thinking-dots {
            display: flex;
            justify-content: center;
            margin-bottom: 0.75rem;
        }
        
        .thinking-dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: #8B5A2B;
            margin: 0 0.25rem;
            animation: thinking 1.5s infinite;
        }
        
        .thinking-dot:nth-child(2) {
            animation-delay: 0.3s;
        }
        
        .thinking-dot:nth-child(3) {
            animation-delay: 0.6s;
        }
        
        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .game-log {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-top: 1rem;
            width: 100%;
        }
        
        @media (min-width: 768px) {
            .game-log {
                margin-top: 1.5rem;
            }
        }
        
        .log-content {
            height: 6rem;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #374151;
            line-height: 1.4;
        }
        
        @media (min-width: 768px) {
            .log-content {
                height: 8rem;
                font-size: 0.875rem;
            }
        }
        
        .log-content p {
            margin-bottom: 0.25rem;
        }
        
        .footer {
            background: #374151;
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 0.875rem;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }
        
        .modal-content {
            background: white;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 1.75rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .rules-list {
            list-style: none;
            text-align: left;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #374151;
        }
        
        .check-icon {
            color: #10b981;
            margin-right: 0.5rem;
            margin-top: 0.125rem;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>五子棋对弈</h1>
            <p>来场挑战，看谁能先连成五子 /•᷅•᷄\୭~</p>
        </header>

        <main class="main">
            <div class="sidebar">
                <div class="info-card">
                    <h2>
                        <span class="icon">ℹ</span>游戏信息
                    </h2>
                    <div class="info-item">
                        <p class="info-label">当前回合</p>
                        <div id="current-player" class="player-indicator">
                            <div id="player-indicator" class="piece black"></div>
                            <span id="player-text">玩家</span>
                        </div>
                    </div>
                    <div class="info-item">
                        <p class="info-label">游戏状态</p>
                        <p id="game-status">游戏进行中</p>
                    </div>
                    <div class="info-item">
                        <p class="info-label">局数统计</p>
                        <p id="game-count">第 1 局</p>
                    </div>
                    <div id="winner-info" class="info-item hidden">
                        <p class="info-label">获胜方</p>
                        <div class="player-indicator">
                            <div id="winner-indicator" class="piece"></div>
                            <span id="winnerText"></span>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">⚙</span>游戏控制
                    </h2>
                    <div class="controls">
                        <button id="new-game" class="btn btn-primary">
                            🔄 新游戏
                        </button>
                        <button id="undo" class="btn btn-secondary">
                            ↶ 悔棋 (<span id="undo-chances">0</span>)
                        </button>
                        <button id="difficulty-toggle" class="btn btn-secondary">
                            ⚡ 难度: <span id="difficulty-text">中等</span>
                        </button>
                        <button id="mode-toggle" class="btn btn-secondary">
                            👥 模式: <span id="mode-text">玩家 vs 开元</span>
                        </button>
                        <button id="music-toggle" class="btn btn-secondary">
                            🎵 音乐: <span id="music-text">暂停</span>
                        </button>

                        <div class="input-group">
                            <p class="info-label">兑换码获取悔棋</p>
                            <input type="text" id="redeem-code-input" placeholder="输入兑换码">
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">💡</span>游戏规则
                    </h2>
                    <ul class="rules-list">
                        <li>
                            <span class="check-icon">✓</span>
                            <span>黑棋先下，白棋后下</span>
                        </li>
                        <li>
                            <span class="check-icon">✓</span>
                            <span>先在横、竖或斜方向连成五子者获胜</span>
                        </li>
                        <li>
                            <span class="check-icon">✓</span>
                            <span>每局结束后黑白互换</span>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="board-area">
                <div class="board-container">
                    <canvas id="board"></canvas>
                    <div id="thinking" class="thinking-overlay">
                        <div class="thinking-content">
                            <div class="thinking-dots">
                                <div class="thinking-dot"></div>
                                <div class="thinking-dot"></div>
                                <div class="thinking-dot"></div>
                            </div>
                            <p style="color: #8B5A2B; font-weight: bold;">开元正在思考...</p>
                        </div>
                    </div>
                </div>

                <div class="game-log">
                    <h3>游戏日志</h3>
                    <div id="game-log" class="log-content">
                        <p style="color: #6b7280; font-style: italic;">游戏开始，请点击棋盘落子</p>
                    </div>
                </div>
            </div>
        </main>

        <footer class="footer">
            <p>五子棋游戏 &copy; 2025 | Designed by 开元</p>
        </footer>
    </div>

    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="winner-modal-title">胜利提示</h2>
            <p id="winner-modal-message"></p>
        </div>
    </div>

    <audio id="music" loop>
        <source src="jasmine_flower" type="audio/mp3">
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const BOARD_SIZE = 15;
            let CELL_SIZE = 40; // Dynamic adjustment
            let PIECE_SIZE = CELL_SIZE * 0.8;
            let BOARD_PADDING = CELL_SIZE;
            
            // Canvas transformation state
            let scale = 1.0;
            let offsetX = 0;
            let offsetY = 0;
            const MIN_SCALE = 0.8; // Minimum zoom level
            const MAX_SCALE = 3.0; // Maximum zoom level

            // Touch state for pan and zoom
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;
            let initialPinchDistance = null;

            // Calculate responsive size
            function calculateResponsiveSize() {
                const container = document.querySelector('.board-area');
                const containerWidth = container.clientWidth;
                
                // Calculate ideal cell size based on container width
                // The board's total intrinsic width is (BOARD_SIZE - 1) * CELL_SIZE + 2 * BOARD_PADDING
                // Since BOARD_PADDING is set to CELL_SIZE, this simplifies to (BOARD_SIZE + 1) * CELL_SIZE
                // So, CELL_SIZE should be containerWidth / (BOARD_SIZE + 1) to fit perfectly
                let calculatedCellSize = containerWidth / (BOARD_SIZE + 1);

                if (window.innerWidth < 480) { // Very small screens (e.g., older phones)
                    CELL_SIZE = Math.max(20, Math.min(28, calculatedCellSize)); 
                } else if (window.innerWidth < 768) { // Tablets or larger phones
                    CELL_SIZE = Math.max(25, Math.min(35, calculatedCellSize)); 
                } else { // Desktop
                    CELL_SIZE = Math.max(30, Math.min(45, calculatedCellSize)); 
                }
                
                PIECE_SIZE = CELL_SIZE * 0.85; 
                BOARD_PADDING = CELL_SIZE; 
            }
            
            // Game state
            let gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            let currentPlayer = 1; // 1: Black, 2: White
            let gameOver = false;
            let difficulty = 2; // 1: Easy, 2: Medium, 3: Hard
            let moveHistory = [];
            let lastMovePosition = null;
            let gameMode = 1; // 1: Player vs AI, 2: Player vs Player
            let gameCount = 1; // Game count
            let playerStartsWithBlack = true; // Does player start with black?
            let undoChances = 0; // New: Undo chances
            
            // DOM elements
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const boardContainer = document.querySelector('.board-container');
            const currentPlayerIndicator = document.getElementById('player-indicator');
            const currentPlayerText = document.getElementById('player-text');
            const gameStatus = document.getElementById('game-status');
            const gameCountDisplay = document.getElementById('game-count');
            const winnerInfo = document.getElementById('winner-info');
            const winnerIndicator = document.getElementById('winner-indicator');
            const winnerText = document.getElementById('winnerText');
            const newGameBtn = document.getElementById('new-game');
            const undoBtn = document.getElementById('undo');
            const undoChancesDisplay = document.getElementById('undo-chances'); // New
            const difficultyToggle = document.getElementById('difficulty-toggle');
            const difficultyText = document.getElementById('difficulty-text');
            const gameLog = document.getElementById('game-log');
            const thinkingIndicator = document.getElementById('thinking');
            const modeToggle = document.getElementById('mode-toggle');
            const modeText = document.getElementById('mode-text');
            const winnerModal = document.getElementById('winner-modal');
            const winnerModalTitle = document.getElementById('winner-modal-title');
            const winnerModalMessage = document.getElementById('winner-modal-message');
            const closeModalBtn = document.querySelector('.close');
            const music = document.getElementById('music');
            const musicToggle = document.getElementById('music-toggle');
            const musicText = document.getElementById('music-text');
            const redeemCodeInput = document.getElementById('redeem-code-input'); // New

            // AI difficulty configuration
            const difficultyConfig = {
                1: { // Easy
                    searchDepth: 2, // Shallow search depth
                    randomMoveChance: 0.4, // High chance of making a random move
                    thinkTimeRange: [200, 1000]
                },
                2: { // Medium
                    searchDepth: 4, // Medium search depth (increased from 3 to 4 for more challenge)
                    randomMoveChance: 0.1, // Low chance of making a random move
                    thinkTimeRange: [500, 3500]
                },
                3: { // Hard
                    searchDepth: 5, // Deeper search depth for stronger play (reduced from 6 to 5 for performance)
                    randomMoveChance: 0.0, // No random moves, always best
                    thinkTimeRange: [800, 5500]
                }
            };

            // Set Canvas size
            function setCanvasSize() {
                calculateResponsiveSize();
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                
                // Get available container width
                const containerWidth = document.querySelector('.board-area').clientWidth;
                const maxDisplaySize = Math.min(containerWidth - 16, window.innerWidth - 32); 
                
                // Calculate final display size
                const displaySize = Math.min(size, maxDisplaySize);
                
                // Set actual canvas size
                canvas.width = size;
                canvas.height = size;
                
                // Set canvas display size
                canvas.style.width = `${displaySize}px`;
                canvas.style.height = `${displaySize}px`;
                
                canvas.dataset.originalWidth = size;
                canvas.dataset.originalHeight = size;
                
                // Reset zoom and pan when resizing
                scale = 1.0;
                offsetX = 0;
                offsetY = 0;

                drawBoard(); // Redraw board after resizing
            }
            
            // Initialize game
            function initGame() {
                gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0)); // Clear board
                currentPlayer = 1; // Always black starts
                gameOver = false;
                moveHistory = [];
                lastMovePosition = null;
                
                // Reset zoom and pan on new game
                scale = 1.0;
                offsetX = 0;
                offsetY = 0;
                
                updateGameStatus();
                clearGameLog();
                logMessage(`第${gameCount}局开始`);
                
                if (playerStartsWithBlack) {
                    logMessage('玩家执黑先手，请点击棋盘落子');
                } else {
                    logMessage('开元执黑先手');
                    // AI starts, will think shortly
                    setTimeout(() => {
                        if (gameMode === 1 && !gameOver) {
                            aiMove();
                        }
                    }, 500);
                }
                
                winnerModal.style.display = 'none';
                updateUndoChancesDisplay(); 
                drawBoard(); // Redraw board after initialization
            }
            
            // Draw board
            function drawBoard() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                ctx.clearRect(0, 0, size, size);

                ctx.save(); // Save the current canvas state

                // Apply pan and zoom transformations
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                
                // Draw board background
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(0, 0, size, size);
                
                // Draw grid lines
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.lineTo(size - BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.stroke();
                    
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING + i * CELL_SIZE, BOARD_PADDING);
                    ctx.lineTo(BOARD_PADDING + i * CELL_SIZE, size - BOARD_PADDING);
                    ctx.stroke();
                }
                
                // Draw star points
                const starPoints = [
                    {x: 3, y: 3}, {x: 3, y: 11}, 
                    {x: 7, y: 7}, // Center point
                    {x: 11, y: 3}, {x: 11, y: 11}
                ];
                
                starPoints.forEach(point => {
                    drawStarPoint(point.x, point.y);
                });
                
                // Draw all pieces
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 1) {
                            drawPiece(i, j, 'black', 1); // Draw at full scale
                        } else if (gameBoard[i][j] === 2) {
                            drawPiece(i, j, 'white', 1); // Draw at full scale
                        }
                    }
                }
                
                // Draw marker for the last move
                if (lastMovePosition) {
                    drawLastMoveMarker(lastMovePosition.x, lastMovePosition.y);
                }

                ctx.restore(); // Restore the canvas state
            }
            
            // Draw star point
            function drawStarPoint(x, y) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                const radius = 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#8B4513';
                ctx.fill();
            }
            
            // Draw piece with enhanced aesthetics and optional scale for animation
            function drawPiece(x, y, color, animationScale = 1) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                const currentPieceSize = PIECE_SIZE * animationScale;

                // Draw subtle shadow for depth
                ctx.beginPath();
                ctx.arc(centerX + 2 * animationScale, centerY + 2 * animationScale, currentPieceSize / 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; 
                ctx.fill();
                
                // Draw piece with radial gradient for glossy effect
                ctx.beginPath();
                ctx.arc(centerX, centerY, currentPieceSize / 2, 0, 2 * Math.PI);
                
                const gradient = ctx.createRadialGradient(
                    centerX - currentPieceSize / 4, centerY - currentPieceSize / 4, currentPieceSize / 10, 
                    centerX, centerY, currentPieceSize / 2 
                );
                
                if (color === 'white') {
                    gradient.addColorStop(0, '#FFFFFF'); 
                    gradient.addColorStop(0.7, '#F0F0F0'); 
                    gradient.addColorStop(1, '#E0E0E0'); 
                    ctx.strokeStyle = '#D9D9D9';
                } else {
                    gradient.addColorStop(0, '#404040'); 
                    gradient.addColorStop(0.7, '#1A1A1A'); 
                    gradient.addColorStop(1, '#000000'); 
                    ctx.strokeStyle = '#333333';
                }
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Animate piece placement
            function animatePiecePlacement(x, y, playerColor) {
                let animationStartTime = null;
                const animationDuration = 200; // milliseconds

                function animate(currentTime) {
                    if (!animationStartTime) {
                        animationStartTime = currentTime;
                    }
                    const elapsedTime = currentTime - animationStartTime;
                    const progress = Math.min(elapsedTime / animationDuration, 1); 

                    const animationScale = 0.5 + (0.5 * progress); 

                    // Redraw the entire board with current pan/zoom before drawing the animating piece
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                    ctx.scale(scale, scale);
                    
                    drawBoardContentOnly(); // Draw grid, star points, and static pieces
                    drawPiece(x, y, playerColor, animationScale); // Draw the animating piece

                    ctx.restore();

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation finished, ensure the final state is drawn correctly
                        drawBoard(); // Full redraw to ensure all pieces are rendered correctly without animation artifacts
                    }
                }
                requestAnimationFrame(animate);
            }

            // Helper to draw board content without transformations (used during animation)
            function drawBoardContentOnly() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                ctx.clearRect(0, 0, size, size);
                
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(0, 0, size, size);
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.lineTo(size - BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING + i * CELL_SIZE, BOARD_PADDING);
                    ctx.lineTo(BOARD_PADDING + i * CELL_SIZE, size - BOARD_PADDING);
                    ctx.stroke();
                }
                
                const starPoints = [
                    {x: 3, y: 3}, {x: 3, y: 11}, 
                    {x: 7, y: 7}, 
                    {x: 11, y: 3}, {x: 11, y: 11}
                ];
                starPoints.forEach(point => {
                    drawStarPoint(point.x, point.y);
                });
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 1) {
                            drawPiece(i, j, 'black', 1);
                        } else if (gameBoard[i][j] === 2) {
                            drawPiece(i, j, 'white', 1);
                        }
                    }
                }
                if (lastMovePosition) {
                    drawLastMoveMarker(lastMovePosition.x, lastMovePosition.y);
                }
            }
            
            // Draw marker for the last move
            function drawLastMoveMarker(x, y) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                const radius = PIECE_SIZE / 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF69B4'; 
                ctx.fill();
            }
            
            // Check for win
            function checkWin(x, y, player) {
                const directions = [
                    [1, 0],   // Horizontal
                    [0, 1],   // Vertical
                    [1, 1],   // Diagonal (down-right)
                    [1, -1]   // Diagonal (up-right)
                ];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    // Check in positive direction
                    for (let i = 1; i < 5; i++) {
                        const nx = x + dx * i;
                        const ny = y + dy * i;
                        
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                        if (gameBoard[nx][ny] !== player) break;
                        
                        count++;
                    }
                    
                    // Check in negative direction
                    for (let i = 1; i < 5; i++) {
                        const nx = x - dx * i;
                        const ny = y - dy * i;
                        
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                        if (gameBoard[nx][ny] !== player) break;
                        
                        count++;
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Check if board is full
            function isBoardFull() {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // Handle player move
            function handlePlayerMove(x, y) {
                if (gameOver || gameBoard[x][y] !== 0) {
                    return;
                }
                
                // Check if it's player's turn
                const isPlayerTurn = (playerStartsWithBlack && currentPlayer === 1) || 
                                   (!playerStartsWithBlack && currentPlayer === 2);
                
                if (gameMode === 1 && !isPlayerTurn) {
                    return; // Not player's turn
                }
                
                // Record move
                gameBoard[x][y] = currentPlayer;
                moveHistory.push({x, y, player: currentPlayer});
                lastMovePosition = {x, y};
                
                // Animate piece placement
                animatePiecePlacement(x, y, currentPlayer === 1 ? 'black' : 'white');

                const playerName = getPlayerName(currentPlayer);
                const pieceColor = currentPlayer === 1 ? '黑' : '白';
                logMessage(`${playerName}在(${x+1},${y+1})落${pieceColor}子`);
                
                // Check if player wins
                if (checkWin(x, y, currentPlayer)) {
                    gameOver = true;
                    const winnerMessage = `${playerName}获胜！`;
                    updateGameStatus(winnerMessage);
                    logMessage(`恭喜，${winnerMessage}`);
                    showWinnerModal(winnerMessage);
                    return;
                }
                
                // Check if board is full
                if (isBoardFull()) {
                    gameOver = true;
                    updateGameStatus('平局！');
                    logMessage('游戏结束，平局！');
                    showWinnerModal('平局！');
                    return;
                }
                
                // Switch player
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateGameStatus();
                
                // If AI vs Player and it's AI's turn
                if (gameMode === 1) {
                    const isAiTurn = (playerStartsWithBlack && currentPlayer === 2) || 
                                   (!playerStartsWithBlack && currentPlayer === 1);
                    
                    if (isAiTurn) {
                        aiMove();
                    }
                }
            }
            
            // AI move
            function aiMove() {
                if (gameOver) return;
                
                // Show thinking indicator
                thinkingIndicator.style.display = 'flex';
                
                const config = difficultyConfig[difficulty];
                const thinkTime = config.thinkTimeRange[0] + 
                                Math.random() * (config.thinkTimeRange[1] - config.thinkTimeRange[0]);
                
                setTimeout(() => {
                    let move;
                    // Introduce randomness for lower difficulties
                    if (Math.random() < config.randomMoveChance) {
                        move = getRandomGoodMove(); // Make a 'good enough' random move
                    } else {
                        move = getBestMove(); // Use Minimax
                    }

                    thinkingIndicator.style.display = 'none';
                    
                    if (move && !gameOver) {
                        const {x, y} = move;
                        
                        // Record AI move
                        gameBoard[x][y] = currentPlayer;
                        moveHistory.push({x, y, player: currentPlayer});
                        lastMovePosition = {x, y};
                        
                        // Animate piece placement
                        animatePiecePlacement(x, y, currentPlayer === 1 ? 'black' : 'white');

                        const aiName = getPlayerName(currentPlayer);
                        const pieceColor = currentPlayer === 1 ? '黑' : '白';
                        logMessage(`${aiName}在(${x+1},${y+1})落${pieceColor}子`);
                        
                        // Check if AI wins
                        if (checkWin(x, y, currentPlayer)) {
                            gameOver = true;
                            const winnerMessage = `${aiName}获胜！`;
                            updateGameStatus(winnerMessage);
                            logMessage(`${winnerMessage}`);
                            showWinnerModal(winnerMessage);
                            return;
                        }
                        
                        // Check if board is full
                        if (isBoardFull()) {
                            gameOver = true;
                            updateGameStatus('平局！');
                            logMessage('游戏结束，平局！');
                            showWinnerModal('平局！');
                            return;
                        }
                        
                        // Switch to player's turn
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateGameStatus();
                    } else if (!move && !gameOver) {
                        // If no best move found (e.g., board is full or no valid moves)
                        // This case should ideally be caught by isBoardFull() earlier
                        console.warn("AI could not find a move, or game is already over.");
                    }
                }, thinkTime);
            }
            
            // Get player name
            function getPlayerName(player) {
                if (gameMode === 2) {
                    return player === 1 ? '玩家1' : '玩家2';
                } else {
                    if (playerStartsWithBlack) {
                        return player === 1 ? '玩家' : '开元';
                    } else {
                        return player === 1 ? '开元' : '玩家';
                    }
                }
            }
            
            // Get best move - using Minimax with Alpha-Beta Pruning
            function getBestMove() {
                const config = difficultyConfig[difficulty];
                
                // First, check for immediate win or block moves
                const winMove = findWinningMove(currentPlayer);
                if (winMove) return winMove;
                
                const opponent = currentPlayer === 1 ? 2 : 1;
                const blockMove = findWinningMove(opponent);
                if (blockMove) return blockMove;
                
                // Use Minimax algorithm to search for the best move
                // The `minimax` function returns an object { score, move }
                const result = minimax(config.searchDepth, -Infinity, Infinity, true, currentPlayer);
                
                if (result.move) {
                    return result.move;
                }
                
                // Fallback to a random good move if minimax fails (shouldn't happen often)
                return getRandomGoodMove();
            }
            
            // Minimax algorithm implementation
            function minimax(depth, alpha, beta, isMaximizingPlayer, player) {
                if (depth === 0 || gameOver) {
                    // Base case: return board evaluation
                    return {
                        score: evaluateBoard(player),
                        move: null
                    };
                }
                
                const moves = getOrderedMoves();
                if (moves.length === 0) return { score: 0, move: null }; // No valid moves
                
                let bestMove = null;
                
                if (isMaximizingPlayer) {
                    let maxScore = -Infinity;
                    
                    for (const move of moves) {
                        gameBoard[move.x][move.y] = player; // Make the move
                        
                        // Check for immediate win after making the move
                        if (checkWin(move.x, move.y, player)) {
                            gameBoard[move.x][move.y] = 0; // Undo the move
                            return { score: 100000000, move }; // Very high score for winning move (increased significantly)
                        }
                        
                        const result = minimax(depth - 1, alpha, beta, false, player === 1 ? 2 : 1);
                        gameBoard[move.x][move.y] = 0; // Undo the move
                        
                        if (result.score > maxScore) {
                            maxScore = result.score;
                            bestMove = move;
                        }
                        
                        alpha = Math.max(alpha, result.score);
                        if (beta <= alpha) break; // Alpha-Beta Pruning
                    }
                    
                    return { score: maxScore, move: bestMove };
                } else { // Minimizing player (opponent)
                    let minScore = Infinity;
                    
                    for (const move of moves) {
                        gameBoard[move.x][move.y] = player; // Make the move
                        
                        // Check for immediate win for opponent after making the move
                        if (checkWin(move.x, move.y, player)) {
                            gameBoard[move.x][move.y] = 0; // Undo the move
                            return { score: -100000000, move }; // Very low score for opponent's winning move (increased significantly)
                        }
                        
                        const result = minimax(depth - 1, alpha, beta, true, player === 1 ? 2 : 1);
                        gameBoard[move.x][move.y] = 0; // Undo the move
                        
                        if (result.score < minScore) {
                            minScore = result.score;
                            bestMove = move;
                        }
                        
                        beta = Math.min(beta, result.score);
                        if (beta <= alpha) break; // Alpha-Beta Pruning
                    }
                    
                    return { score: minScore, move: bestMove };
                }
            }
            
            // Get ordered candidate moves (heuristic sorting)
            function getOrderedMoves() {
                const moves = [];
                
                // Iterate over a slightly larger area around existing pieces for efficiency
                // This helps focus the search on relevant areas
                let minX = BOARD_SIZE, maxX = -1, minY = BOARD_SIZE, maxY = -1;
                let hasPieces = false;

                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] !== 0) {
                            hasPieces = true;
                            minX = Math.min(minX, i);
                            maxX = Math.max(maxX, i);
                            minY = Math.min(minY, j);
                            maxY = Math.max(maxY, j);
                        }
                    }
                }

                if (!hasPieces) {
                    // If board is empty, suggest center move
                    moves.push({ x: Math.floor(BOARD_SIZE / 2), y: Math.floor(BOARD_SIZE / 2), score: 0 });
                    return moves;
                }

                // Expand search area slightly
                const searchMinX = Math.max(0, minX - 2);
                const searchMaxX = Math.min(BOARD_SIZE - 1, maxX + 2);
                const searchMinY = Math.max(0, minY - 2);
                const searchMaxY = Math.min(BOARD_SIZE - 1, maxY + 2);

                for (let i = searchMinX; i <= searchMaxX; i++) {
                    for (let j = searchMinY; j <= searchMaxY; j++) {
                        if (gameBoard[i][j] === 0) {
                            // Evaluate position for both current player and opponent to find critical spots
                            const scoreForPlayer = evaluatePosition(i, j, currentPlayer);
                            const scoreForOpponent = evaluatePosition(i, j, currentPlayer === 1 ? 2 : 1);
                            // Combine scores, prioritizing moves that create threats for self or block opponent's threats
                            const combinedScore = scoreForPlayer + scoreForOpponent * 3.5; 
                            moves.push({ x: i, y: j, score: combinedScore });
                        }
                    }
                }
                
                // Sort by score in descending order, prioritize higher-scoring moves
                return moves.sort((a, b) => b.score - a.score).slice(0, 40); 
            }
            
            // Check if position has adjacent pieces (within a 2-unit radius)
            function hasAdjacentPieces(x, y) {
                for (let i = Math.max(0, x-2); i <= Math.min(BOARD_SIZE-1, x+2); i++) {
                    for (let j = Math.max(0, y-2); j <= Math.min(BOARD_SIZE-1, y+2); j++) {
                        if (gameBoard[i][j] !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Find a winning move
            function findWinningMove(player) {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            gameBoard[i][j] = player;
                            if (checkWin(i, j, player)) {
                                gameBoard[i][j] = 0; 
                                return { x: i, y: j };
                            }
                            gameBoard[i][j] = 0; 
                        }
                    }
                }
                return null;
            }
            
            // Evaluate the entire board state
            function evaluateBoard(player) {
                let totalScore = 0;
                const opponent = player === 1 ? 2 : 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === player) {
                            totalScore += evaluatePosition(i, j, player);
                        } else if (gameBoard[i][j] === opponent) {
                            totalScore -= evaluatePosition(i, j, opponent) * 3.5; 
                        }
                    }
                }
                
                return totalScore;
            }
            
            // Evaluate score for a specific position (improved for AlphaGo-like precision)
            function evaluatePosition(x, y, player) {
                const directions = [
                    [1, 0],   // Horizontal
                    [0, 1],   // Vertical
                    [1, 1],   // Diagonal (down-right)
                    [1, -1]   // Diagonal (up-right)
                ];
                
                let totalPatternScore = 0;
                let liveThreeCount = 0;
                let blockedFourCount = 0;
                let liveFourCount = 0;
                let sleepFourCount = 0; 

                for (const [dx, dy] of directions) {
                    const pattern = getPattern(x, y, dx, dy, player);
                    const score = evaluatePattern(pattern);
                    totalPatternScore += score; 

                    if (pattern.includes('_PPPP_')) {
                        liveFourCount++;
                    }
                    if (pattern.includes('BPPPP_') || pattern.includes('_PPPPH') || pattern.includes('BPPPP') || pattern.includes('PPPPB')) {
                        blockedFourCount++;
                    }
                    if ((pattern.includes('_PPP_') && !pattern.includes('_PPPP_')) ||
                        (pattern.includes('_P_PP_') && !pattern.includes('_P_PPP_')) ||
                        (pattern.includes('_PP_P_') && !pattern.includes('_PP_PP_'))) {
                        liveThreeCount++;
                    }
                    if (pattern.includes('PPPP_') || pattern.includes('_PPPP')) {
                        sleepFourCount++;
                    }
                }
                
                // Add bonuses for combinations of threats (AlphaGo-like compound threats)
                if (liveFourCount >= 1) { 
                    totalPatternScore += 10000000; 
                }
                if (liveThreeCount >= 2) { 
                    totalPatternScore += 800000; 
                }
                if (liveThreeCount >= 1 && blockedFourCount >= 1) { 
                    totalPatternScore += 700000; 
                }
                if (blockedFourCount >= 2) { 
                    totalPatternScore += 600000; 
                }
                if (sleepFourCount >= 1 && liveThreeCount >= 1) { 
                    totalPatternScore += 400000; 
                }
                
                const centerDist = Math.max(Math.abs(x - Math.floor(BOARD_SIZE/2)), Math.abs(y - Math.floor(BOARD_SIZE/2)));
                const centerBonus = (7 - centerDist) * 25; 
                
                return totalPatternScore + centerBonus;
            }
            
            // Get pattern string around a position
            function getPattern(x, y, dx, dy, player) {
                let pattern = '';
                const opponent = player === 1 ? 2 : 1;
                
                for (let i = -4; i <= 4; i++) {
                    const nx = x + dx * i;
                    const ny = y + dy * i;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        pattern += 'B'; 
                    } else if (gameBoard[nx][ny] === player) {
                        pattern += 'P'; 
                    } else if (gameBoard[nx][ny] === opponent) {
                        pattern += 'O'; 
                    } else {
                        pattern += '_'; 
                    }
                }
                
                return pattern;
            }
            
            // Evaluate pattern score (more detailed patterns)
            function evaluatePattern(pattern) {
                // P: Player's piece, O: Opponent's piece, _: Empty, B: Boundary/Blocked
                
                if (pattern.includes('PPPPP')) return 10000000; 
                
                if (pattern.includes('_PPPP_')) return 1000000; 
                if (pattern.includes('_P_PPP_') || pattern.includes('_PP_PP_') || pattern.includes('_PPP_P_')) return 500000; 
                
                if (pattern.includes('BPPPP_') || pattern.includes('_PPPPH') || pattern.includes('BPPPP') || pattern.includes('PPPPB')) return 100000; 
                if (pattern.includes('P_PPP') || pattern.includes('PP_PP') || pattern.includes('PPP_P')) return 80000; 

                if (pattern.includes('_PPP_')) return 10000; 
                if (pattern.includes('_P_PP_') || pattern.includes('_PP_P_')) return 5000; 

                if (pattern.includes('BPPP_') || pattern.includes('_PPPB')) return 1000; 
                if (pattern.includes('BP_PP_') || pattern.includes('_PP_PB')) return 500; 

                if (pattern.includes('__PP__')) return 200; 
                if (pattern.includes('__P_P__')) return 150; 

                if (pattern.includes('BPP__') || pattern.includes('__PPB')) return 50; 
                
                return 1; 
            }
            
            // Get a random 'good enough' move for easier difficulties
            function getRandomGoodMove() {
                const moves = [];
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0 && hasAdjacentPieces(i, j)) {
                            moves.push({ x: i, y: j });
                        }
                    }
                }
                
                if (moves.length === 0) {
                    return getRandomMove();
                }
                
                return moves[Math.floor(Math.random() * moves.length)];
            }
            
            // Get a purely random move (fallback)
            function getRandomMove() {
                const moves = [];
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            moves.push({ x: i, y: j });
                        }
                    }
                }
                if (moves.length > 0) {
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                return null;
            }
            
            // Update game status UI
            function updateGameStatus(message) {
                gameCountDisplay.textContent = `第 ${gameCount} 局`;
                
                if (message) {
                    gameStatus.textContent = message;
                    winnerInfo.classList.remove('hidden');
                    
                    if (message.includes('玩家1') || (message.includes('玩家') && !message.includes('玩家2'))) {
                        const isBlack = (playerStartsWithBlack && gameMode === 1) || 
                                       (gameMode === 2 && currentPlayer === 1);
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = gameMode === 2 ? '玩家1' : '玩家';
                    } else if (message.includes('玩家2')) {
                        const isBlack = gameMode === 2 && currentPlayer === 2;
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = '玩家2';
                    } else if (message.includes('开元')) {
                        const isBlack = !playerStartsWithBlack;
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = '开元';
                    } else {
                        winnerInfo.classList.add('hidden');
                    }
                } else {
                    gameStatus.textContent = '游戏进行中';
                    winnerInfo.classList.add('hidden');
                    
                    const isCurrentPlayerBlack = currentPlayer === 1;
                    currentPlayerIndicator.className = `piece ${isCurrentPlayerBlack ? 'black' : 'white'}`;
                    
                    if (gameMode === 2) {
                        currentPlayerText.textContent = currentPlayer === 1 ? '玩家1' : '玩家2';
                    } else {
                        if (playerStartsWithBlack) {
                            currentPlayerText.textContent = currentPlayer === 1 ? '玩家' : '开元';
                        } else {
                            currentPlayerText.textContent = currentPlayer === 1 ? '开元' : '玩家';
                        }
                    }
                }
            }
            
            // Start a new game
            function startNewGame() {
                gameCount++;
                if (gameMode === 1) {
                    playerStartsWithBlack = !playerStartsWithBlack;
                }
                initGame();
            }
            
            // Log game messages
            function logMessage(message) {
                const logEntry = document.createElement('p');
                logEntry.textContent = message;
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }
            
            // Clear game log
            function clearGameLog() {
                gameLog.innerHTML = '';
            }
            
            // Show winner modal
            function showWinnerModal(message) {
                winnerModalTitle.textContent = '游戏结束';
                winnerModalMessage.textContent = message;
                winnerModal.style.display = 'block';
            }

            // Update undo chances display
            function updateUndoChancesDisplay() {
                undoChancesDisplay.textContent = undoChances;
            }

            // Handle redeem code submission
            function handleRedeemCode() {
                const code = redeemCodeInput.value.trim().toLowerCase();
                if (code === 'kaiyuan') {
                    undoChances++;
                    logMessage('成功兑换1次悔棋机会！');
                    updateUndoChancesDisplay();
                } else {
                    logMessage('兑换码无效。');
                }
                redeemCodeInput.value = ''; 
            }
            
            // Music play/pause functionality
            musicToggle.addEventListener('click', () => {
                if (music.paused) {
                    music.play().catch(() => {
                        logMessage('音乐播放失败');
                    });
                    musicText.textContent = '播放';
                } else {
                    music.pause();
                    musicText.textContent = '暂停';
                }
            });
            
            // Initialize game
            initGame();
            
            // --- Touch and Mouse Event Handling for Zoom/Pan and Click ---

            // Convert screen coordinates to board coordinates (considering zoom/pan)
            function getBoardCoordinates(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;

                // Apply inverse transformation
                const boardX = (canvasX / scale) - (offsetX / scale);
                const boardY = (canvasY / scale) - (offsetY / scale);

                const gridX = Math.round((boardX - BOARD_PADDING) / CELL_SIZE);
                const gridY = Math.round((boardY - BOARD_PADDING) / CELL_SIZE);

                return { gridX, gridY };
            }

            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                lastX = event.clientX;
                lastY = event.clientY;
            });

            canvas.addEventListener('mousemove', (event) => {
                if (isDragging && event.buttons === 1) { // Check if left mouse button is down
                    const dx = event.clientX - lastX;
                    const dy = event.clientY - lastY;
                    offsetX += dx;
                    offsetY += dy;
                    lastX = event.clientX;
                    lastY = event.clientY;
                    drawBoard();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false; // Reset dragging if mouse leaves canvas
            });

            canvas.addEventListener('wheel', (event) => {
                event.preventDefault(); // Prevent page scrolling
                const zoomFactor = 1.1;
                const oldScale = scale;

                // Get mouse position relative to canvas (before scaling)
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                if (event.deltaY < 0) { // Zoom in
                    scale *= zoomFactor;
                } else { // Zoom out
                    scale /= zoomFactor;
                }

                scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));

                // Adjust offset to zoom towards the mouse pointer
                offsetX = mouseX - ((mouseX - offsetX) / oldScale) * scale;
                offsetY = mouseY - ((mouseY - offsetY) / oldScale) * scale;

                drawBoard();
            });

            // Touch events for pan and zoom
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent page scrolling and default touch actions
                if (gameOver) return;

                if (event.touches.length === 1) {
                    isDragging = true;
                    lastX = event.touches[0].clientX;
                    lastY = event.touches[0].clientY;
                    initialPinchDistance = null; // Reset pinch distance
                } else if (event.touches.length === 2) {
                    isDragging = false; // Disable single-finger drag when two fingers are down
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Prevent page scrolling and default touch actions
                if (gameOver) return;

                if (event.touches.length === 1 && isDragging) {
                    const dx = event.touches[0].clientX - lastX;
                    const dy = event.touches[0].clientY - lastY;
                    offsetX += dx;
                    offsetY += dy;
                    lastX = event.touches[0].clientX;
                    lastY = event.touches[0].clientY;
                    drawBoard();
                } else if (event.touches.length === 2 && initialPinchDistance !== null) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const currentPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    
                    const oldScale = scale;
                    scale *= (currentPinchDistance / initialPinchDistance);
                    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));

                    // Adjust offset to zoom towards the center of the pinch
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    const rect = canvas.getBoundingClientRect();
                    const canvasCenterX = centerX - rect.left;
                    const canvasCenterY = centerY - rect.top;

                    offsetX = canvasCenterX - ((canvasCenterX - offsetX) / oldScale) * scale;
                    offsetY = canvasCenterY - ((canvasCenterY - offsetY) / oldScale) * scale;

                    initialPinchDistance = currentPinchDistance; // Update for next move event
                    drawBoard();
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (event) => {
                isDragging = false;
                initialPinchDistance = null;

                // If it was a tap (single touch, no significant movement)
                if (event.changedTouches.length === 1) {
                    const touch = event.changedTouches[0];
                    // Check if it was a quick tap without much movement (threshold for tap vs drag)
                    const dx = Math.abs(touch.clientX - lastX);
                    const dy = Math.abs(touch.clientY - lastY);
                    if (dx < 5 && dy < 5) { // Small movement threshold for a tap
                        const { gridX, gridY } = getBoardCoordinates(touch.clientX, touch.clientY);
                        if (gridX >= 0 && gridX < BOARD_SIZE && gridY >= 0 && gridY < BOARD_SIZE) {
                            handlePlayerMove(gridX, gridY);
                        }
                    }
                }
            });

            // Re-adjust board on window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    setCanvasSize();
                }, 150);
            });
            
            // New game button event
            newGameBtn.addEventListener('click', () => {
                startNewGame();
            });
            
            // Undo button event
            undoBtn.addEventListener('click', () => {
                if (gameOver) {
                    logMessage('游戏已结束，无法悔棋。');
                    return;
                }

                if (gameMode === 1 && undoChances <= 0) {
                    logMessage('悔棋机会不足，请尝试兑换。');
                    return;
                }

                if (moveHistory.length === 0) {
                    logMessage('棋盘上没有可悔的棋子。');
                    return;
                }
                
                // For AI vs Player, undo two steps (player and AI)
                // For Player vs Player, undo one step
                const undoCount = gameMode === 1 ? Math.min(2, moveHistory.length) : 1;
                
                if (gameMode === 1) { // Only consume undo chance in PvE mode
                    undoChances--;
                }
                
                for (let i = 0; i < undoCount; i++) {
                    if (moveHistory.length > 0) {
                        const lastMove = moveHistory.pop();
                        gameBoard[lastMove.x][lastMove.y] = 0;
                        currentPlayer = lastMove.player;
                    }
                }
                
                lastMovePosition = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                gameOver = false;
                drawBoard();
                updateGameStatus();
                updateUndoChancesDisplay();
                logMessage(`悔棋 ${undoCount} 步`);

                // If AI's turn after undo in PvE, trigger AI move
                if (gameMode === 1) {
                    const isAiTurn = (playerStartsWithBlack && currentPlayer === 2) || 
                                     (!playerStartsWithBlack && currentPlayer === 1);
                    if (isAiTurn) {
                        aiMove();
                    }
                }
            });
            
            // Difficulty toggle button event
            difficultyToggle.addEventListener('click', () => {
                difficulty = (difficulty % 3) + 1;
                const difficultyLevels = ['简单', '中等', '困难'];
                const winRates = ['较低', '中等', '较高']; 
                difficultyText.textContent = `${difficultyLevels[difficulty - 1]}(胜率约${winRates[difficulty - 1]})`;
                logMessage(`游戏难度已切换至 ${difficultyLevels[difficulty - 1]} (AI胜率约${winRates[difficulty - 1]})`);
            });
            
            // Mode toggle button event
            modeToggle.addEventListener('click', () => {
                gameMode = gameMode === 1 ? 2 : 1;
                const modeNames = ['玩家 vs 开元', '玩家 vs 玩家'];
                modeText.textContent = modeNames[gameMode - 1];
                playerStartsWithBlack = true; 
                gameCount = 1; 
                logMessage(`游戏模式已切换至 ${modeNames[gameMode - 1]}`);
                initGame();
            });
            
            // Close modal button event
            closeModalBtn.addEventListener('click', () => {
                winnerModal.style.display = 'none';
                startNewGame(); 
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target === winnerModal) {
                    winnerModal.style.display = 'none';
                    startNewGame(); 
                }
            });

            // Redeem code input event listeners
            redeemCodeInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    handleRedeemCode();
                }
            });

            redeemCodeInput.addEventListener('input', () => {
                const value = redeemCodeInput.value.trim();
                if (value.length === 7 && /^[a-zA-Z0-9\u4e00-\u9fa5]+$/.test(value)) {
                    handleRedeemCode();
                }
            });
        });
    </script>
</body>
</html>
