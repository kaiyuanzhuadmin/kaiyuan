<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹å¯¹å¼ˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='%238B5A2B'><circle cx='50' cy='50' r='40' fill='white' stroke='%238B5A2B' stroke-width='4'/><circle cx='50' cy='50' r='10' fill='%238B5A2B'/></svg>" type="image/svg+xml">
    <style>
        /* æœ¬åœ°åŒ–æ ·å¼ï¼Œæ›¿ä»£Tailwind CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'SimHei', Arial, sans-serif;
            background: linear-gradient(135deg, #fef7ed 0%, #fed7aa 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        .container {
            max-width: 80rem;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
        }
        
        .header {
            background: #8B5A2B;
            color: white;
            padding: 2rem;
            text-align: center;
        }
        
        .header h1 {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: bold;
            letter-spacing: 0.025em;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            color: #D2B48C;
            font-size: clamp(1rem, 2vw, 1.2rem);
        }
        
        .main {
            padding: 2rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }
        
        .sidebar {
            flex: 1;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .board-area {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .info-card {
            background: #f9fafb;
            padding: 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .info-card h2 {
            font-size: 1.25rem;
            font-weight: bold;
            color: #374151;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }
        
        .icon {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
            color: #8B5A2B;
        }
        
        .info-item {
            margin-bottom: 1rem;
        }
        
        .info-item:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: #6b7280;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .player-indicator {
            display: flex;
            align-items: center;
            margin-top: 0.25rem;
        }
        
        .piece {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            margin-right: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .piece.black {
            background: #000000;
            border: 2px solid #374151;
        }
        
        .piece.white {
            background: #ffffff;
            border: 2px solid #d1d5db;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .btn {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #8B5A2B;
            color: white;
        }
        
        .btn-primary:hover {
            background: #7c4f26;
        }
        
        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }
        
        .btn-secondary:hover {
            background: #d1d5db;
        }
        
        .board-container {
            position: relative;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }
        
        #board {
            background: #DEB887;
            display: block;
        }
        
        .thinking-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .thinking-content {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        
        .thinking-dots {
            display: flex;
            justify-content: center;
            margin-bottom: 0.75rem;
        }
        
        .thinking-dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: #8B5A2B;
            margin: 0 0.25rem;
            animation: thinking 1.5s infinite;
        }
        
        .thinking-dot:nth-child(2) {
            animation-delay: 0.3s;
        }
        
        .thinking-dot:nth-child(3) {
            animation-delay: 0.6s;
        }
        
        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .game-log {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-top: 1.5rem;
        }
        
        .game-log h3 {
            font-weight: bold;
            color: #374151;
            margin-bottom: 0.5rem;
        }
        
        .log-content {
            height: 8rem;
            overflow-y: auto;
            font-size: 0.875rem;
            color: #374151;
        }
        
        .log-content p {
            margin-bottom: 0.25rem;
        }
        
        .footer {
            background: #374151;
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 0.875rem;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }
        
        .modal-content {
            background: white;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 1.75rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .rules-list {
            list-style: none;
            text-align: left;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #374151;
        }
        
        .check-icon {
            color: #10b981;
            margin-right: 0.5rem;
            margin-top: 0.125rem;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- æ¸¸æˆæ ‡é¢˜ -->
        <header class="header">
            <h1>äº”å­æ£‹å¯¹å¼ˆ</h1>
            <p>æ¥åœºæŒ‘æˆ˜ï¼Œçœ‹è°èƒ½å…ˆè¿æˆäº”å­ /â€¢á·…â€¢á·„\à­­~</p>
        </header>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <main class="main">
            <!-- æ¸¸æˆä¿¡æ¯å’Œæ§åˆ¶åŒº -->
            <div class="sidebar">
                <div class="info-card">
                    <h2>
                        <span class="icon">â„¹</span>æ¸¸æˆä¿¡æ¯
                    </h2>
                    <div class="info-item">
                        <p class="info-label">å½“å‰å›åˆ</p>
                        <div id="current-player" class="player-indicator">
                            <div id="player-indicator" class="piece black"></div>
                            <span id="player-text">ç©å®¶</span>
                        </div>
                    </div>
                    <div class="info-item">
                        <p class="info-label">æ¸¸æˆçŠ¶æ€</p>
                        <p id="game-status">æ¸¸æˆè¿›è¡Œä¸­</p>
                    </div>
                    <div class="info-item">
                        <p class="info-label">å±€æ•°ç»Ÿè®¡</p>
                        <p id="game-count">ç¬¬ 1 å±€</p>
                    </div>
                    <div id="winner-info" class="info-item hidden">
                        <p class="info-label">è·èƒœæ–¹</p>
                        <div class="player-indicator">
                            <div id="winner-indicator" class="piece"></div>
                            <span id="winner-text"></span>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">âš™</span>æ¸¸æˆæ§åˆ¶
                    </h2>
                    <div class="controls">
                        <button id="new-game" class="btn btn-primary">
                            ğŸ”„ æ–°æ¸¸æˆ
                        </button>
                        <button id="undo" class="btn btn-secondary">
                            â†¶ æ‚”æ£‹
                        </button>
                        <button id="difficulty-toggle" class="btn btn-secondary">
                            âš¡ éš¾åº¦: <span id="difficulty-text">ä¸­ç­‰</span>
                        </button>
                        <button id="mode-toggle" class="btn btn-secondary">
                            ğŸ‘¥ æ¨¡å¼: <span id="mode-text">ç©å®¶ vs å¼€å…ƒ</span>
                        </button>
                        <button id="music-toggle" class="btn btn-secondary">
                            ğŸµ éŸ³ä¹: <span id="music-text">æš‚åœ</span>
                        </button>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">ğŸ’¡</span>æ¸¸æˆè§„åˆ™
                    </h2>
                    <ul class="rules-list">
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>é»‘æ£‹å…ˆä¸‹ï¼Œç™½æ£‹åä¸‹</span>
                        </li>
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>å…ˆåœ¨æ¨ªã€ç«–æˆ–æ–œæ–¹å‘è¿æˆäº”å­è€…è·èƒœ</span>
                        </li>
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>æ¯å±€ç»“æŸåé»‘ç™½äº’æ¢</span>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- æ£‹ç›˜åŒºåŸŸ -->
            <div class="board-area">
                <div class="board-container">
                    <canvas id="board"></canvas>
                    <div id="thinking" class="thinking-overlay">
                        <div class="thinking-content">
                            <div class="thinking-dots">
                                <div class="thinking-dot"></div>
                                <div class="thinking-dot"></div>
                                <div class="thinking-dot"></div>
                            </div>
                            <p style="color: #8B5A2B; font-weight: bold;">å¼€å…ƒæ­£åœ¨æ€è€ƒ...</p>
                        </div>
                    </div>
                </div>

                <div class="game-log">
                    <h3>æ¸¸æˆæ—¥å¿—</h3>
                    <div id="game-log" class="log-content">
                        <p style="color: #6b7280; font-style: italic;">æ¸¸æˆå¼€å§‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­</p>
                    </div>
                </div>
            </div>
        </main>

        <!-- é¡µè„š -->
        <footer class="footer">
            <p>äº”å­æ£‹æ¸¸æˆ &copy; 2025 | Designed by å¼€å…ƒ</p>
        </footer>
    </div>

    <!-- èƒœåˆ©æç¤ºæ¨¡æ€æ¡† -->
    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="winner-modal-title">èƒœåˆ©æç¤º</h2>
            <p id="winner-modal-message"></p>
        </div>
    </div>

    <!-- æ·»åŠ éŸ³é¢‘å…ƒç´  -->
    <audio id="music" loop>
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+D2um0fCEOfyvi2ayEhDz2m4vOwYxwCL3y5zNmUVhIM" type="audio/wav">
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // æ¸¸æˆå¸¸é‡
            const BOARD_SIZE = 15;
            const CELL_SIZE = 40;
            const PIECE_SIZE = CELL_SIZE * 0.8;
            const BOARD_PADDING = CELL_SIZE;
            
            // æ¸¸æˆçŠ¶æ€
            let gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            let currentPlayer = 1; // 1:å½“å‰æ‰§é»‘æ–¹, 2:å½“å‰æ‰§ç™½æ–¹
            let gameOver = false;
            let difficulty = 2; // 1:ç®€å•(èƒœç‡30%), 2:ä¸­ç­‰(èƒœç‡60%), 3:å›°éš¾(èƒœç‡85%)
            let moveHistory = [];
            let lastMovePosition = null;
            let gameMode = 1; // 1: ç©å®¶ vs å¼€å…ƒ, 2: ç©å®¶ vs ç©å®¶
            let gameCount = 1; // æ¸¸æˆå±€æ•°
            let playerStartsWithBlack = true; // ç©å®¶æ˜¯å¦æ‰§é»‘å…ˆæ‰‹
            
            // DOMå…ƒç´ 
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const boardContainer = document.querySelector('.board-container');
            const currentPlayerIndicator = document.getElementById('player-indicator');
            const currentPlayerText = document.getElementById('player-text');
            const gameStatus = document.getElementById('game-status');
            const gameCountDisplay = document.getElementById('game-count');
            const winnerInfo = document.getElementById('winner-info');
            const winnerIndicator = document.getElementById('winner-indicator');
            const winnerText = document.getElementById('winner-text');
            const newGameBtn = document.getElementById('new-game');
            const undoBtn = document.getElementById('undo');
            const difficultyToggle = document.getElementById('difficulty-toggle');
            const difficultyText = document.getElementById('difficulty-text');
            const gameLog = document.getElementById('game-log');
            const thinkingIndicator = document.getElementById('thinking');
            const modeToggle = document.getElementById('mode-toggle');
            const modeText = document.getElementById('mode-text');
            const winnerModal = document.getElementById('winner-modal');
            const winnerModalTitle = document.getElementById('winner-modal-title');
            const winnerModalMessage = document.getElementById('winner-modal-message');
            const closeModalBtn = document.querySelector('.close');
            const music = document.getElementById('music');
            const musicToggle = document.getElementById('music-toggle');
            const musicText = document.getElementById('music-text');

            // AIéš¾åº¦é…ç½®
            const difficultyConfig = {
                1: { // ç®€å•
                    searchDepth: 1,
                    winRate: 0.3,
                    thinkTimeRange: [200, 800],
                    randomFactor: 0.4
                },
                2: { // ä¸­ç­‰
                    searchDepth: 2,
                    winRate: 0.6,
                    thinkTimeRange: [500, 1500],
                    randomFactor: 0.2
                },
                3: { // å›°éš¾
                    searchDepth: 3,
                    winRate: 0.85,
                    thinkTimeRange: [800, 2500],
                    randomFactor: 0.1
                }
            };

            // è®¾ç½®Canvaså°ºå¯¸
            function setCanvasSize() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                canvas.width = size;
                canvas.height = size;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                setCanvasSize();
                drawBoard();
                gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                currentPlayer = 1; // æ€»æ˜¯é»‘æ£‹å…ˆæ‰‹
                gameOver = false;
                moveHistory = [];
                lastMovePosition = null;
                
                updateGameStatus();
                clearGameLog();
                logMessage(`ç¬¬${gameCount}å±€å¼€å§‹`);
                
                if (playerStartsWithBlack) {
                    logMessage('ç©å®¶æ‰§é»‘å…ˆæ‰‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­');
                } else {
                    logMessage('å¼€å…ƒæ‰§é»‘å…ˆæ‰‹');
                    // å¼€å…ƒå…ˆæ‰‹ï¼Œç¨åå¼€å§‹æ€è€ƒ
                    setTimeout(() => {
                        if (gameMode === 1 && !gameOver) {
                            aiMove();
                        }
                    }, 500);
                }
                
                winnerModal.style.display = 'none';
            }
            
            // ç»˜åˆ¶æ£‹ç›˜
            function drawBoard() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                ctx.clearRect(0, 0, size, size);
                
                // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(0, 0, size, size);
                
                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.lineTo(size - BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.stroke();
                    
                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING + i * CELL_SIZE, BOARD_PADDING);
                    ctx.lineTo(BOARD_PADDING + i * CELL_SIZE, size - BOARD_PADDING);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½
                const starPoints = [
                    {x: 3, y: 3}, {x: 3, y: 11}, 
                    {x: 7, y: 7}, // å¤©å…ƒ
                    {x: 11, y: 3}, {x: 11, y: 11}
                ];
                
                starPoints.forEach(point => {
                    drawStarPoint(point.x, point.y);
                });
                
                // ç»˜åˆ¶æ‰€æœ‰æ£‹å­
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 1) {
                            drawPiece(i, j, 'black');
                        } else if (gameBoard[i][j] === 2) {
                            drawPiece(i, j, 'white');
                        }
                    }
                }
                
                // ç»˜åˆ¶æœ€åä¸€æ­¥çš„æ ‡è®°
                if (lastMovePosition) {
                    drawLastMoveMarker(lastMovePosition.x, lastMovePosition.y);
                }
            }
            
            // ç»˜åˆ¶æ˜Ÿä½
            function drawStarPoint(x, y) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                const radius = 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#8B4513';
                ctx.fill();
            }
            
            // ç»˜åˆ¶æ£‹å­
            function drawPiece(x, y, color) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                
                // ç»˜åˆ¶é˜´å½±
                ctx.beginPath();
                ctx.arc(centerX + 2, centerY + 2, PIECE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fill();
                
                // ç»˜åˆ¶æ£‹å­
                ctx.beginPath();
                ctx.arc(centerX, centerY, PIECE_SIZE / 2, 0, 2 * Math.PI);
                
                // åˆ›å»ºå¾„å‘æ¸å˜
                const gradient = ctx.createRadialGradient(
                    centerX - PIECE_SIZE / 5, centerY - PIECE_SIZE / 5, PIECE_SIZE / 10,
                    centerX, centerY, PIECE_SIZE / 2
                );
                
                if (color === 'white') {
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(1, '#E6E6E6');
                    ctx.strokeStyle = '#D9D9D9';
                } else {
                    gradient.addColorStop(0, '#404040');
                    gradient.addColorStop(1, '#000000');
                    ctx.strokeStyle = '#333333';
                }
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // ç»˜åˆ¶æœ€åä¸€æ­¥çš„æ ‡è®°
            function drawLastMoveMarker(x, y) {
                const centerX = BOARD_PADDING + x * CELL_SIZE;
                const centerY = BOARD_PADDING + y * CELL_SIZE;
                const radius = PIECE_SIZE / 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF69B4';
                ctx.fill();
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶è·èƒœ
            function checkWin(x, y, player) {
                const directions = [
                    [1, 0],   // æ°´å¹³
                    [0, 1],   // å‚ç›´
                    [1, 1],   // å³ä¸‹å¯¹è§’çº¿
                    [1, -1]   // å³ä¸Šå¯¹è§’çº¿
                ];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    // æ­£å‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x + dx * i;
                        const ny = y + dy * i;
                        
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                        if (gameBoard[nx][ny] !== player) break;
                        
                        count++;
                    }
                    
                    // åå‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x - dx * i;
                        const ny = y - dy * i;
                        
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                        if (gameBoard[nx][ny] !== player) break;
                        
                        count++;
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
            function isBoardFull() {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // å¤„ç†ç©å®¶è½å­
            function handlePlayerMove(x, y) {
                if (gameOver || gameBoard[x][y] !== 0) {
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦è½®åˆ°ç©å®¶
                const isPlayerTurn = (playerStartsWithBlack && currentPlayer === 1) || 
                                   (!playerStartsWithBlack && currentPlayer === 2);
                
                if (gameMode === 1 && !isPlayerTurn) {
                    return; // ä¸æ˜¯ç©å®¶å›åˆ
                }
                
                // è®°å½•è½å­
                gameBoard[x][y] = currentPlayer;
                moveHistory.push({x, y, player: currentPlayer});
                lastMovePosition = {x, y};
                
                // æ›´æ–°UI
                drawBoard();
                const playerName = getPlayerName(currentPlayer);
                const pieceColor = currentPlayer === 1 ? 'é»‘' : 'ç™½';
                logMessage(`${playerName}åœ¨(${x+1},${y+1})è½${pieceColor}å­`);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦è·èƒœ
                if (checkWin(x, y, currentPlayer)) {
                    gameOver = true;
                    const winnerMessage = `${playerName}è·èƒœï¼`;
                    updateGameStatus(winnerMessage);
                    logMessage(`æ­å–œï¼Œ${winnerMessage}`);
                    showWinnerModal(winnerMessage);
                    return;
                }
                
                // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
                if (isBoardFull()) {
                    gameOver = true;
                    updateGameStatus('å¹³å±€ï¼');
                    logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                    showWinnerModal('å¹³å±€ï¼');
                    return;
                }
                
                // åˆ‡æ¢ç©å®¶
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateGameStatus();
                
                // å¦‚æœæ˜¯äººæœºå¯¹æˆ˜ä¸”è½®åˆ°AI
                if (gameMode === 1) {
                    const isAiTurn = (playerStartsWithBlack && currentPlayer === 2) || 
                                   (!playerStartsWithBlack && currentPlayer === 1);
                    
                    if (isAiTurn) {
                        aiMove();
                    }
                }
            }
            
            // AIè½å­
            function aiMove() {
                if (gameOver) return;
                
                // æ˜¾ç¤ºæ€è€ƒæŒ‡ç¤ºå™¨
                thinkingIndicator.style.display = 'flex';
                
                const config = difficultyConfig[difficulty];
                const thinkTime = config.thinkTimeRange[0] + 
                                Math.random() * (config.thinkTimeRange[1] - config.thinkTimeRange[0]);
                
                setTimeout(() => {
                    const move = getBestMove();
                    thinkingIndicator.style.display = 'none';
                    
                    if (move && !gameOver) {
                        const {x, y} = move;
                        
                        // è®°å½•AIè½å­
                        gameBoard[x][y] = currentPlayer;
                        moveHistory.push({x, y, player: currentPlayer});
                        lastMovePosition = {x, y};
                        
                        // æ›´æ–°UI
                        drawBoard();
                        const aiName = getPlayerName(currentPlayer);
                        const pieceColor = currentPlayer === 1 ? 'é»‘' : 'ç™½';
                        logMessage(`${aiName}åœ¨(${x+1},${y+1})è½${pieceColor}å­`);
                        
                        // æ£€æŸ¥AIæ˜¯å¦è·èƒœ
                        if (checkWin(x, y, currentPlayer)) {
                            gameOver = true;
                            const winnerMessage = `${aiName}è·èƒœï¼`;
                            updateGameStatus(winnerMessage);
                            logMessage(`${winnerMessage}`);
                            showWinnerModal(winnerMessage);
                            return;
                        }
                        
                        // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
                        if (isBoardFull()) {
                            gameOver = true;
                            updateGameStatus('å¹³å±€ï¼');
                            logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                            showWinnerModal('å¹³å±€ï¼');
                            return;
                        }
                        
                        // åˆ‡æ¢åˆ°ç©å®¶å›åˆ
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateGameStatus();
                    }
                }, thinkTime);
            }
            
            // è·å–ç©å®¶åç§°
            function getPlayerName(player) {
                if (gameMode === 2) {
                    return player === 1 ? 'ç©å®¶1' : 'ç©å®¶2';
                } else {
                    if (playerStartsWithBlack) {
                        return player === 1 ? 'ç©å®¶' : 'å¼€å…ƒ';
                    } else {
                        return player === 1 ? 'å¼€å…ƒ' : 'ç©å®¶';
                    }
                }
            }
            
            // è·å–æœ€ä½³ç§»åŠ¨ - ä½¿ç”¨Alpha-Betaå‰ªæçš„Minimaxç®—æ³•
            function getBestMove() {
                const config = difficultyConfig[difficulty];
                
                // æ ¹æ®éš¾åº¦è°ƒæ•´èƒœç‡
                if (Math.random() > config.winRate) {
                    // æ•…æ„é€‰æ‹©è¾ƒå·®çš„ç§»åŠ¨æ¥é™ä½èƒœç‡
                    return getRandomOrWeakMove();
                }
                
                // é¦–å…ˆæ£€æŸ¥å¿…èƒœå’Œå¿…é˜²
                const winMove = findWinningMove(currentPlayer);
                if (winMove) return winMove;
                
                const blockMove = findWinningMove(currentPlayer === 1 ? 2 : 1);
                if (blockMove) return blockMove;
                
                // ä½¿ç”¨Minimaxç®—æ³•æœç´¢æœ€ä½³ç§»åŠ¨
                const result = minimax(config.searchDepth, -Infinity, Infinity, true, currentPlayer);
                
                if (result.move) {
                    // æ·»åŠ éšæœºå› å­
                    if (Math.random() < config.randomFactor) {
                        return getGoodRandomMove();
                    }
                    return result.move;
                }
                
                return getGoodRandomMove();
            }
            
            // Minimaxç®—æ³•å®ç°
            function minimax(depth, alpha, beta, isMaximizing, player) {
                if (depth === 0 || gameOver) {
                    return {
                        score: evaluateBoard(player),
                        move: null
                    };
                }
                
                const moves = getOrderedMoves();
                if (moves.length === 0) return { score: 0, move: null };
                
                let bestMove = null;
                
                if (isMaximizing) {
                    let maxScore = -Infinity;
                    
                    for (const move of moves) {
                        gameBoard[move.x][move.y] = player;
                        
                        if (checkWin(move.x, move.y, player)) {
                            gameBoard[move.x][move.y] = 0;
                            return { score: 10000, move };
                        }
                        
                        const result = minimax(depth - 1, alpha, beta, false, player === 1 ? 2 : 1);
                        gameBoard[move.x][move.y] = 0;
                        
                        if (result.score > maxScore) {
                            maxScore = result.score;
                            bestMove = move;
                        }
                        
                        alpha = Math.max(alpha, result.score);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    
                    return { score: maxScore, move: bestMove };
                } else {
                    let minScore = Infinity;
                    
                    for (const move of moves) {
                        gameBoard[move.x][move.y] = player;
                        
                        if (checkWin(move.x, move.y, player)) {
                            gameBoard[move.x][move.y] = 0;
                            return { score: -10000, move };
                        }
                        
                        const result = minimax(depth - 1, alpha, beta, true, player === 1 ? 2 : 1);
                        gameBoard[move.x][move.y] = 0;
                        
                        if (result.score < minScore) {
                            minScore = result.score;
                            bestMove = move;
                        }
                        
                        beta = Math.min(beta, result.score);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    
                    return { score: minScore, move: bestMove };
                }
            }
            
            // è·å–æœ‰åºçš„å€™é€‰ç§»åŠ¨ï¼ˆå¯å‘å¼æ’åºï¼‰
            function getOrderedMoves() {
                const moves = [];
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0 && hasAdjacentPieces(i, j)) {
                            const score = evaluatePosition(i, j, currentPlayer);
                            moves.push({ x: i, y: j, score });
                        }
                    }
                }
                
                // æŒ‰åˆ†æ•°é™åºæ’åºï¼Œä¼˜å…ˆè¯„ä¼°é«˜åˆ†ç§»åŠ¨
                return moves.sort((a, b) => b.score - a.score).slice(0, 20); // é™åˆ¶å€™é€‰æ•°é‡
            }
            
            // æ£€æŸ¥ä½ç½®å‘¨å›´æ˜¯å¦æœ‰æ£‹å­
            function hasAdjacentPieces(x, y) {
                for (let i = Math.max(0, x-2); i <= Math.min(BOARD_SIZE-1, x+2); i++) {
                    for (let j = Math.max(0, y-2); j <= Math.min(BOARD_SIZE-1, y+2); j++) {
                        if (gameBoard[i][j] !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // å¯»æ‰¾è·èƒœç§»åŠ¨
            function findWinningMove(player) {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            gameBoard[i][j] = player;
                            if (checkWin(i, j, player)) {
                                gameBoard[i][j] = 0;
                                return { x: i, y: j };
                            }
                            gameBoard[i][j] = 0;
                        }
                    }
                }
                return null;
            }
            
            // è¯„ä¼°æ•´ä¸ªæ£‹ç›˜
            function evaluateBoard(player) {
                let totalScore = 0;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === player) {
                            totalScore += evaluatePosition(i, j, player);
                        } else if (gameBoard[i][j] !== 0) {
                            totalScore -= evaluatePosition(i, j, gameBoard[i][j]);
                        }
                    }
                }
                
                return totalScore;
            }
            
            // è¯„ä¼°ä½ç½®åˆ†æ•°ï¼ˆæ”¹è¿›ç‰ˆï¼‰
            function evaluatePosition(x, y, player) {
                const directions = [
                    [1, 0],   // æ°´å¹³
                    [0, 1],   // å‚ç›´
                    [1, 1],   // å³ä¸‹å¯¹è§’çº¿
                    [1, -1]   // å³ä¸Šå¯¹è§’çº¿
                ];
                
                let maxScore = 0;
                
                for (const [dx, dy] of directions) {
                    const pattern = getPattern(x, y, dx, dy, player);
                    const score = evaluatePattern(pattern);
                    maxScore = Math.max(maxScore, score);
                }
                
                // ä½ç½®åŠ æˆï¼ˆä¸­å¿ƒåŒºåŸŸæ›´æœ‰ä»·å€¼ï¼‰
                const centerBonus = 5 - Math.max(Math.abs(x - 7), Math.abs(y - 7));
                
                return maxScore + centerBonus;
            }
            
            // è·å–æ¨¡å¼å­—ç¬¦ä¸²
            function getPattern(x, y, dx, dy, player) {
                let pattern = '';
                
                // å‘å‰æ£€æŸ¥4æ ¼
                for (let i = -4; i <= 4; i++) {
                    const nx = x + dx * i;
                    const ny = y + dy * i;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        pattern += 'X'; // è¾¹ç•Œ
                    } else if (i === 0) {
                        pattern += 'O'; // å½“å‰ä½ç½®
                    } else if (gameBoard[nx][ny] === player) {
                        pattern += 'O'; // å·±æ–¹æ£‹å­
                    } else if (gameBoard[nx][ny] === 0) {
                        pattern += '_'; // ç©ºä½
                    } else {
                        pattern += 'X'; // å¯¹æ–¹æ£‹å­æˆ–è¾¹ç•Œ
                    }
                }
                
                return pattern;
            }
            
            // è¯„ä¼°æ¨¡å¼åˆ†æ•°
            function evaluatePattern(pattern) {
                // äº”è¿
                if (pattern.includes('OOOOO')) return 10000;
                
                // æ´»å››
                if (pattern.includes('_OOOO_')) return 5000;
                
                // å†²å››
                if (pattern.includes('XOOOO_') || pattern.includes('_OOOOX')) return 1000;
                
                // æ´»ä¸‰
                if (pattern.includes('_OOO_')) return 500;
                if (pattern.includes('_O_OO_') || pattern.includes('_OO_O_')) return 500;
                
                // çœ ä¸‰
                if (pattern.includes('XOOO_') || pattern.includes('_OOOX')) return 100;
                if (pattern.includes('XO_OO_') || pattern.includes('_OO_OX')) return 100;
                
                // æ´»äºŒ
                if (pattern.includes('_OO_')) return 50;
                if (pattern.includes('_O_O_')) return 50;
                
                // çœ äºŒ
                if (pattern.includes('XOO_') || pattern.includes('_OOUX')) return 10;
                
                return 1;
            }
            
            // è·å–éšæœºæˆ–è¾ƒå¼±çš„ç§»åŠ¨ï¼ˆé™ä½èƒœç‡ç”¨ï¼‰
            function getRandomOrWeakMove() {
                const moves = [];
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0 && hasAdjacentPieces(i, j)) {
                            moves.push({ x: i, y: j });
                        }
                    }
                }
                
                if (moves.length === 0) {
                    return getRandomMove();
                }
                
                // éšæœºé€‰æ‹©ä¸€ä¸ªå€™é€‰ä½ç½®
                return moves[Math.floor(Math.random() * moves.length)];
            }
            
            // è·å–å¥½çš„éšæœºç§»åŠ¨
            function getGoodRandomMove() {
                return getRandomOrWeakMove();
            }
            
            // è·å–éšæœºç§»åŠ¨
            function getRandomMove() {
                const moves = [];
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 0) {
                            moves.push({ x: i, y: j });
                        }
                    }
                }
                
                if (moves.length > 0) {
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                
                return null;
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€UI
            function updateGameStatus(message) {
                gameCountDisplay.textContent = `ç¬¬ ${gameCount} å±€`;
                
                if (message) {
                    gameStatus.textContent = message;
                    winnerInfo.classList.remove('hidden');
                    
                    if (message.includes('ç©å®¶1') || (message.includes('ç©å®¶') && !message.includes('ç©å®¶2'))) {
                        const isBlack = (playerStartsWithBlack && gameMode === 1) || 
                                       (gameMode === 2 && currentPlayer === 1);
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = gameMode === 2 ? 'ç©å®¶1' : 'ç©å®¶';
                    } else if (message.includes('ç©å®¶2')) {
                        const isBlack = gameMode === 2 && currentPlayer === 2;
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = 'ç©å®¶2';
                    } else if (message.includes('å¼€å…ƒ')) {
                        const isBlack = !playerStartsWithBlack;
                        winnerIndicator.className = `piece ${isBlack ? 'black' : 'white'}`;
                        winnerText.textContent = 'å¼€å…ƒ';
                    } else {
                        winnerInfo.classList.add('hidden');
                    }
                } else {
                    gameStatus.textContent = 'æ¸¸æˆè¿›è¡Œä¸­';
                    winnerInfo.classList.add('hidden');
                    
                    // æ›´æ–°å½“å‰ç©å®¶æŒ‡ç¤ºå™¨
                    const isCurrentPlayerBlack = currentPlayer === 1;
                    currentPlayerIndicator.className = `piece ${isCurrentPlayerBlack ? 'black' : 'white'}`;
                    
                    if (gameMode === 2) {
                        currentPlayerText.textContent = currentPlayer === 1 ? 'ç©å®¶1' : 'ç©å®¶2';
                    } else {
                        if (playerStartsWithBlack) {
                            currentPlayerText.textContent = currentPlayer === 1 ? 'ç©å®¶' : 'å¼€å…ƒ';
                        } else {
                            currentPlayerText.textContent = currentPlayer === 1 ? 'å¼€å…ƒ' : 'ç©å®¶';
                        }
                    }
                }
            }
            
            // å¼€å§‹æ–°æ¸¸æˆ
            function startNewGame() {
                gameCount++;
                // é»‘ç™½äº’æ¢
                if (gameMode === 1) {
                    playerStartsWithBlack = !playerStartsWithBlack;
                }
                initGame();
            }
            
            // æ¸¸æˆæ—¥å¿—è®°å½•
            function logMessage(message) {
                const logEntry = document.createElement('p');
                logEntry.textContent = message;
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }
            
            // æ¸…é™¤æ¸¸æˆæ—¥å¿—
            function clearGameLog() {
                gameLog.innerHTML = '';
            }
            
            // æ˜¾ç¤ºèƒœåˆ©æ¨¡æ€æ¡†
            function showWinnerModal(message) {
                winnerModalTitle.textContent = 'æ¸¸æˆç»“æŸ';
                winnerModalMessage.textContent = message;
                winnerModal.style.display = 'block';
            }
            
            // éŸ³ä¹æ’­æ”¾/æš‚åœåŠŸèƒ½
            musicToggle.addEventListener('click', () => {
                if (music.paused) {
                    music.play().catch(() => {
                        // éŸ³é¢‘æ’­æ”¾å¤±è´¥æ—¶çš„å¤„ç†
                        logMessage('éŸ³ä¹æ’­æ”¾å¤±è´¥');
                    });
                    musicText.textContent = 'æ’­æ”¾';
                } else {
                    music.pause();
                    musicText.textContent = 'æš‚åœ';
                }
            });
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
            
            // å¤„ç†æ£‹ç›˜ç‚¹å‡»äº‹ä»¶
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round((event.clientX - rect.left - BOARD_PADDING) / CELL_SIZE);
                const y = Math.round((event.clientY - rect.top - BOARD_PADDING) / CELL_SIZE);
                
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                    handlePlayerMove(x, y);
                }
            });
            
            // æ–°æ¸¸æˆæŒ‰é’®äº‹ä»¶
            newGameBtn.addEventListener('click', () => {
                startNewGame();
            });
            
            // æ‚”æ£‹æŒ‰é’®äº‹ä»¶
            undoBtn.addEventListener('click', () => {
                if (moveHistory.length === 0) return;
                
                // äººæœºå¯¹æˆ˜æ—¶éœ€è¦æ‚”ä¸¤æ­¥ï¼ˆç©å®¶å’ŒAIå„ä¸€æ­¥ï¼‰
                const undoCount = gameMode === 1 ? Math.min(2, moveHistory.length) : 1;
                
                for (let i = 0; i < undoCount; i++) {
                    if (moveHistory.length > 0) {
                        const lastMove = moveHistory.pop();
                        gameBoard[lastMove.x][lastMove.y] = 0;
                        currentPlayer = lastMove.player;
                    }
                }
                
                lastMovePosition = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                gameOver = false;
                drawBoard();
                updateGameStatus();
                logMessage(`æ‚”æ£‹ ${undoCount} æ­¥`);
            });
            
            // éš¾åº¦åˆ‡æ¢æŒ‰é’®äº‹ä»¶
            difficultyToggle.addEventListener('click', () => {
                difficulty = (difficulty % 3) + 1;
                const difficultyLevels = ['ç®€å•', 'ä¸­ç­‰', 'å›°éš¾'];
                const winRates = ['30%', '60%', '85%'];
                difficultyText.textContent = `${difficultyLevels[difficulty - 1]}(${winRates[difficulty - 1]})`;
                logMessage(`æ¸¸æˆéš¾åº¦å·²åˆ‡æ¢è‡³ ${difficultyLevels[difficulty - 1]} (AIèƒœç‡çº¦${winRates[difficulty - 1]})`);
            });
            
            // æ¨¡å¼åˆ‡æ¢æŒ‰é’®äº‹ä»¶
            modeToggle.addEventListener('click', () => {
                gameMode = gameMode === 1 ? 2 : 1;
                const modeNames = ['ç©å®¶ vs å¼€å…ƒ', 'ç©å®¶ vs ç©å®¶'];
                modeText.textContent = modeNames[gameMode - 1];
                playerStartsWithBlack = true; // é‡ç½®ä¸ºç©å®¶æ‰§é»‘
                gameCount = 1; // é‡ç½®å±€æ•°
                logMessage(`æ¸¸æˆæ¨¡å¼å·²åˆ‡æ¢è‡³ ${modeNames[gameMode - 1]}`);
                initGame();
            });
            
            // å…³é—­æ¨¡æ€æ¡†æŒ‰é’®äº‹ä»¶
            closeModalBtn.addEventListener('click', () => {
                winnerModal.style.display = 'none';
            });
            
            // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
            window.addEventListener('click', (event) => {
                if (event.target === winnerModal) {
                    winnerModal.style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
