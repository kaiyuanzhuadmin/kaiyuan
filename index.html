<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>äº”å­æ£‹å¯¹å¼ˆ</title>
    <link rel="icon" type="image/png" sizes="96x96" href="me.png">
    <link rel="preload" href="jasmine_flower.mp3" as="audio">
    <style>
        /* Styles remain the same as the original for brevity... */
        /* æ ·å¼ä¸åŸç‰ˆç›¸åŒï¼Œæ­¤å¤„ä¸ºç®€æ´çœç•¥... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'SimHei', Arial, sans-serif;
            background-color: #E0EEE0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0.5rem;
            margin: 0;
            position: relative;
            overflow-y: auto;
        }

        .background-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('forest.webp'); /* Placeholder image */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.8;
            z-index: -1;
        }
        
        @media (min-width: 768px) {
            body {
                justify-content: center;
                padding: 1rem;
            }
        }
        
        .container {
            max-width: 80rem;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.4); 
            border-radius: 0.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            min-height: calc(100vh - 1rem);
            display: flex;
            flex-direction: column;
            z-index: 1;
        }
        
        @media (min-width: 768px) {
            .container {
                border-radius: 0.75rem;
                min-height: auto;
            }
        }
        
        .header {
            background: #8B5A2B;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        @media (min-width: 768px) {
            .header {
                padding: 2rem;
            }
        }
        
        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: bold;
            letter-spacing: 0.025em;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            color: #D2B48C;
            font-size: clamp(0.9rem, 2vw, 1.2rem);
        }
        
        .main {
            padding: 1rem;
            display: flex;
            gap: 1rem;
            flex-direction: column;
        }
        
        @media (min-width: 768px) {
            .main {
                padding: 2rem;
                flex-direction: row;
                gap: 2rem;
            }
        }
        
        .sidebar {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        @media (min-width: 768px) {
            .sidebar {
                flex: 1;
                min-width: 280px;
                gap: 1.5rem;
            }
        }
        
        .board-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }
        
        @media (min-width: 768px) {
            .board-area {
                flex: 2;
                padding: 0 1rem;
            }
        }
        
        .info-card {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        @media (min-width: 768px) {
            .info-card {
                padding: 1.25rem;
            }
        }
        
        .info-card h2 {
            font-size: 1.1rem;
            font-weight: bold;
            color: #374151;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }
        
        @media (min-width: 768px) {
            .info-card h2 {
                font-size: 1.25rem;
                margin-bottom: 1rem;
            }
        }
        
        .icon {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
            color: #8B5A2B;
        }
        
        .info-item {
            margin-bottom: 1rem;
        }
        
        .info-item:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: #6b7280;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .player-indicator {
            display: flex;
            align-items: center;
            margin-top: 0.25rem;
        }
        
        .piece {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            margin-right: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .piece.black {
            background: #000000;
            border: 2px solid #374151;
        }
        
        .piece.white {
            background: #ffffff;
            border: 2px solid #d1d5db;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .input-group input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            color: #374151;
            width: 100%;
        }

        .input-group input:focus {
            outline: none;
            border-color: #8B5A2B;
            box-shadow: 0 0 0 2px rgba(139, 90, 43, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #8B5A2B;
            color: white;
        }
        
        .btn-primary:hover {
            background: #7c4f26;
        }
        
        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }
        
        .btn-secondary:hover {
            background: #d1d5db;
        }
        
        .board-container {
            position: relative;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), 0 6px 6px rgba(0, 0, 0, 0.15);
            border: 2px solid rgba(139, 90, 43, 0.7);
            width: fit-content;
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.6); 
            touch-action: none;
        }
        
        @media (max-width: 480px) {
            .board-container {
                margin: 0 auto;
                border-radius: 0.5rem;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            }
        }
        
        #board {
            background: #DEB887;
            display: block;
            max-width: 100%;
            height: auto;
            transform-origin: 0 0;
            transition: transform 0.5s ease-out;
        }
        
        @keyframes thinking-animation {
            0% { content: "æ€è€ƒä¸­"; }
            25% { content: "æ€è€ƒä¸­."; }
            50% { content: "æ€è€ƒä¸­.."; }
            75% { content: "æ€è€ƒä¸­..."; }
            100% { content: "æ€è€ƒä¸­"; }
        }

        .thinking-status::after {
            content: "æ€è€ƒä¸­";
            animation: thinking-animation 1.5s linear infinite;
            display: inline-block;
            width: 4.5em;
            text-align: left;
        }
        
        .game-log {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-top: 1rem;
            width: 100%;
        }
        
        @media (min-width: 768px) {
            .game-log {
                margin-top: 1.5rem;
            }
        }
        
        .log-content {
            height: 6rem;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #374151;
            line-height: 1.4;
        }
        
        @media (min-width: 768px) {
            .log-content {
                height: 8rem;
                font-size: 0.875rem;
            }
        }
        
        .log-content p {
            margin-bottom: 0.25rem;
        }
        
        .footer {
            background: #374151;
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 0.875rem;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }
        
        .modal-content {
            background: white;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 1.75rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .rules-list {
            list-style: none;
            text-align: left;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #374151;
        }
        
        .check-icon {
            color: #10b981;
            margin-right: 0.5rem;
            margin-top: 0.125rem;
        }
        
        .hidden {
            display: none !important;
        }

        /* Countdown Window Styles */
        #countdown-window {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
        }

        #countdown-window.show {
            display: block;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="background-overlay"></div>

    <div class="container">
        <header class="header">
            <h1>äº”å­æ£‹å¯¹å¼ˆ</h1>
            <p>å’Œå¼€å…ƒæ¥åœºæŒ‘æˆ˜ï¼Œçœ‹è°èƒ½å…ˆè¿æˆäº”å­ /â€¢á·…â€¢á·„\à­­~</p>
        </header>

        <main class="main">
            <div class="sidebar">
                <div class="info-card">
                    <h2>
                        <span class="icon">â„¹</span>æ¸¸æˆä¿¡æ¯
                    </h2>
                    <div class="info-item">
                        <p class="info-label">å½“å‰å›åˆ</p>
                        <div id="current-player" class="player-indicator">
                            <div id="player-indicator" class="piece black"></div>
                            <span id="player-text">ç©å®¶</span>
                        </div>
                    </div>
                    <div class="info-item">
                        <p class="info-label">æ¸¸æˆçŠ¶æ€</p>
                        <p id="game-status">æ¸¸æˆè¿›è¡Œä¸­</p>
                    </div>
                    <div class="info-item">
                        <p class="info-label">å±€æ•°ç»Ÿè®¡</p>
                        <p id="game-count">ç¬¬ 1 å±€</p>
                    </div>
                    <div id="winner-info" class="info-item hidden">
                        <p class="info-label">è·èƒœæ–¹</p>
                        <div class="player-indicator">
                            <div id="winner-indicator" class="piece"></div>
                            <span id="winnerText"></span>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">âš™</span>æ¸¸æˆæ§åˆ¶
                    </h2>
                    <div class="controls">
                        <button id="new-game" class="btn btn-primary">
                            ğŸ”„ æ–°æ¸¸æˆ
                        </button>
                        <button id="undo" class="btn btn-secondary">
                            â†©ï¸ æ‚”æ£‹ (<span id="undo-chances">0</span>)
                        </button>
                        <button id="difficulty-toggle" class="btn btn-secondary">
                            âš¡ éš¾åº¦: <span id="difficulty-text">ä¸­ç­‰</span>
                        </button>
                        <button id="mode-toggle" class="btn btn-secondary">
                            ğŸ‘¥ æ¨¡å¼: <span id="mode-text">ç©å®¶ vs å¼€å…ƒ</span>
                        </button>
                        <button id="music-toggle" class="btn btn-secondary">
                            ğŸµ éŸ³ä¹: <span id="music-text">æš‚åœ</span>
                        </button>

                        <div class="input-group">
                            <p class="info-label">å…‘æ¢ç è·å–æ‚”æ£‹</p>
                            <input type="text" id="redeem-code-input" placeholder="è¾“å…¥å…‘æ¢ç ">
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h2>
                        <span class="icon">ğŸ’¡</span>æ¸¸æˆè§„åˆ™
                    </h2>
                    <ul class="rules-list">
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>é»‘æ£‹å…ˆä¸‹ï¼Œç™½æ£‹åä¸‹</span>
                        </li>
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>å…ˆåœ¨æ¨ªã€ç«–æˆ–æ–œæ–¹å‘è¿æˆäº”å­è€…è·èƒœ</span>
                        </li>
                        <li>
                            <span class="check-icon">âœ“</span>
                            <span>æ¯å±€ç»“æŸåé»‘ç™½äº’æ¢</span>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="board-area">
                <div class="board-container">
                    <canvas id="board"></canvas>
                </div>

                <div class="game-log">
                    <h3>æ¸¸æˆæ—¥å¿—</h3>
                    <div id="game-log" class="log-content">
                        <p style="color: #6b7280; font-style: italic;">æ¸¸æˆå¼€å§‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­</p>
                    </div>
                </div>
            </div>
        </main>

        <footer class="footer">
            <p>äº”å­æ£‹å¯¹å¼ˆ (äº‘è®¡ç®—) &copy; 2025 | Designed by å¼€å…ƒ</p>
        </footer>
    </div>

    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="winner-modal-title">èƒœåˆ©æç¤º</h2>
            <p id="winner-modal-message"></p>
        </div>
    </div>

    <!-- New: Countdown window for inactivity -->
    <div id="countdown-window">
        <span id="countdown-text"></span>
    </div>

    <audio id="music" loop autoplay>
        <source src="https://placehold.co/1x1/E0EEE0/374151?text=Audio+Placeholder" type="audio/mp3"> <!-- Placeholder audio -->
    </audio>

    <!-- ================================================================= -->
    <!-- ======================= AI WEB WORKER SCRIPT ====================== -->
    <!-- ================================================================= -->
    <script id="ai-worker" type="javascript/worker">
        // This script runs in a separate thread and will not block the UI.
        
        // Game constants (must be redefined in worker scope)
        const BOARD_SIZE = 15;
        let gameBoard; // Will be updated by message from main thread

        // AI difficulty configuration (must be redefined in worker scope)
        const difficultyConfig = {
            1: { searchDepth: 4, randomMoveChance: 0.0 },
            2: { searchDepth: 4, randomMoveChance: 0.0 },
            3: { searchDepth: 4, randomMoveChance: 0.0 }
        };

        // New: Transposition table for caching board states
        const transpositionTable = new Map();

        // New: Function to generate a unique hash for the current board state
        // This is used to generate a unique hash value for the current board state.
        // For a more robust production environment solution, consider using Zobrist hashing.
        function getBoardHash(board) {
            return board.flat().join('');
        }

        // --- All AI calculation functions are moved here ---
        // All AI calculation functions are moved here.
        function evaluatePattern(pattern) {
            // P: Player's piece, O: Opponent's piece, _: Empty, B: Boundary/Blocked
            // Five in a row (winning condition)
            if (pattern.includes('PPPPP')) return 100000;

            // Live Four: _PPPP_
            if (pattern.includes('_PPPP_')) return 10000;
            if (pattern.includes('_P_PPP_') || pattern.includes('_PP_PP_') || pattern.includes('_PPP_P_')) return 7000;
            
            // Blocked Four (å†²å››)
            if (pattern.includes('BPPPP_') || pattern.includes('_PPPPH') || pattern.includes('BPPPP') || pattern.includes('PPPPB')) return 1200;
            if (pattern.includes('P_PPP') || pattern.includes('PP_PP') || pattern.includes('PPP_P')) return 1800;

            // Live Three: _PPP_
            if (pattern.includes('_PPP_')) return 690;
            if (pattern.includes('_P_PP_') || pattern.includes('_PP_P_')) return 660;

            // Blocked Three (çœ ä¸‰)
            if (pattern.includes('BPPP_') || pattern.includes('_PPPB')) return 100;
            if (pattern.includes('BP_PP_') || pattern.includes('_PP_PB')) return 150;

            // Live Two: __PP__
            if (pattern.includes('__PP__')) return 100;
            if (pattern.includes('__P_P__')) return 82;

            // Blocked Two (çœ äºŒ)
            if (pattern.includes('BPP___') || pattern.includes('___PPB')) return 8;
            
            // Live One (æ´»ä¸€)
            if (pattern.includes('_P_')) return 10;
            
            // Defensive evaluation (opponent's patterns)
            // Defensive evaluation (opponent's patterns)
            const opponentPattern = pattern.replace(/P/g, 'TEMP').replace(/O/g, 'P').replace(/TEMP/g, 'O');
            if (opponentPattern.includes('PPPPP')) return -900000;
            if (opponentPattern.includes('_PPPP_')) return -40000;
            if (opponentPattern.includes('BPPPP_') || opponentPattern.includes('_PPPPB')) return -10000;
            if (opponentPattern.includes('P_PPP_') || opponentPattern.includes('_PPP_P')) return -10000;
            if (opponentPattern.includes('_PPP_')) return -4500;
            if (opponentPattern.includes('_P_PP_') || opponentPattern.includes('_PP_P_')) return -4090;
            if (opponentPattern.includes('BPPP__') || opponentPattern.includes('__PPPB')) return -2600;
            if (opponentPattern.includes('_PP_')) return -200;
            
            return 1;
        }

        // Evaluate the offensive and defensive value of a single position
        // è¯„ä¼°å•ä¸ªä½ç½®çš„æ”»é˜²ä»·å€¼
        function evaluatePosition(row, col, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            let totalScore = 0;
            const centerRow = Math.floor(BOARD_SIZE / 2);
            const centerCol = Math.floor(BOARD_SIZE / 2);
            const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
            totalScore += Math.max(0, 10 - distanceFromCenter); // Extra score for being close to the center
            
            directions.forEach(([dx, dy]) => {
                let pattern = '';
                for (let i = -4; i <= 4; i++) {
                    const newRow = row + i * dx;
                    const newCol = col + i * dy;
                    if (newRow < 0 || newRow >= BOARD_SIZE || newCol < 0 || newCol >= BOARD_SIZE) {
                        pattern += 'B'; // Boundary
                    } else if (gameBoard[newRow][newCol] === player) {
                        pattern += 'P'; // Own piece
                    } else if (gameBoard[newRow][newCol] === 0) {
                        pattern += '_'; // Empty
                    } else {
                        pattern += 'O'; // Opponent's piece
                    }
                }
                const midIndex = 4;
                // Mark the current move position as own piece to evaluate its value
                // å°†å½“å‰è½å­ä½ç½®æ ‡è®°ä¸ºå·±æ–¹æ£‹å­ï¼Œä»¥è¯„ä¼°è¯¥ä½ç½®çš„ä»·å€¼
                pattern = pattern.substring(0, midIndex) + 'P' + pattern.substring(midIndex + 1);
                totalScore += evaluatePattern(pattern);
            });
            return totalScore;
        }

        // Check for win
        // æ£€æŸ¥æ˜¯å¦è·èƒœ
        function checkWin(x, y, player) {
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; // Horizontal, vertical, main diagonal, anti-diagonal
            for (const [dx, dy] of directions) {
                let count = 1;
                // Check in one direction
                // å‘ä¸€ä¸ªæ–¹å‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const nx = x + dx * i;
                    const ny = y + dy * i;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || gameBoard[nx][ny] !== player) break;
                    count++;
                }
                // Check in the other direction
                // å‘å¦ä¸€ä¸ªæ–¹å‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const nx = x - dx * i;
                    const ny = y - dy * i;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || gameBoard[nx][ny] !== player) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // Evaluate the value of the entire board
        // è¯„ä¼°æ•´ä¸ªæ£‹ç›˜çš„ä»·å€¼
        function evaluateBoard(player) {
            let totalScore = 0;
            const opponent = player === 1 ? 2 : 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameBoard[i][j] === player) {
                        totalScore += evaluatePosition(i, j, player); // Offensive value of own pieces
                    } else if (gameBoard[i][j] === opponent) {
                        totalScore -= evaluatePosition(i, j, opponent) * 3.0; // Threat value of opponent's pieces (doubled penalty)
                    }
                }
            }
            return totalScore;
        }

        // Get and sort possible moves
        // è·å–å¹¶æ’åºå¯èƒ½çš„èµ°æ³•
        function getOrderedMoves(currentPlayer) {
            const moves = [];
            let minX = BOARD_SIZE, maxX = -1, minY = BOARD_SIZE, maxY = -1;
            let hasPieces = false;

            // Find the minimum and maximum boundaries of existing pieces on the board
            // æ‰¾åˆ°æ£‹ç›˜ä¸Šå·²æœ‰æ£‹å­çš„æœ€å°å’Œæœ€å¤§è¾¹ç•Œ
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameBoard[i][j] !== 0) {
                        hasPieces = true;
                        minX = Math.min(minX, i);
                        maxX = Math.max(maxX, i);
                        minY = Math.min(minY, j);
                        maxY = Math.max(maxY, j);
                    }
                }
            }

            if (!hasPieces) {
                // If the board is empty, suggest placing a piece in the center
                // å¦‚æœæ£‹ç›˜ä¸ºç©ºï¼Œå»ºè®®åœ¨ä¸­å¿ƒè½å­
                moves.push({ x: Math.floor(BOARD_SIZE / 2), y: Math.floor(BOARD_SIZE / 2), score: 0 });
                return moves;
            }

            // Search in the area around existing pieces to reduce unnecessary calculations
            // åœ¨å·²æœ‰æ£‹å­å‘¨å›´çš„åŒºåŸŸè¿›è¡Œæœç´¢ï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—
            const searchMinX = Math.max(0, minX - 2);
            const searchMaxX = Math.min(BOARD_SIZE - 1, maxX + 2);
            const searchMinY = Math.max(0, minY - 2);
            const searchMaxY = Math.min(BOARD_SIZE - 1, maxY + 2);

            for (let i = searchMinX; i <= searchMaxX; i++) {
                for (let j = searchMinY; j <= searchMaxY; j++) {
                    if (gameBoard[i][j] === 0) { // Only consider empty positions
                        const scoreForPlayer = evaluatePosition(i, j, currentPlayer);
                        const scoreForOpponent = evaluatePosition(i, j, currentPlayer === 1 ? 2 : 1);
                        // Combined offensive and defensive value: offensive score + defensive score (opponent's threat) * 3.0
                        // ç»¼åˆæ”»é˜²ä»·å€¼ï¼šè¿›æ”»åˆ†æ•° + é˜²å®ˆåˆ†æ•°ï¼ˆå¯¹æ‰‹å¨èƒï¼‰* 3.0
                        const combinedScore = scoreForPlayer + scoreForOpponent * 3.0; 
                        moves.push({ x: i, y: j, score: combinedScore });
                    }
                }
            }
            // Sort in descending order by combined score, and limit the number of moves searched for efficiency
            // æ ¹æ®ç»¼åˆåˆ†æ•°é™åºæ’åºï¼Œå¹¶é™åˆ¶æœç´¢çš„èµ°æ³•æ•°é‡ï¼Œæé«˜æ•ˆç‡
            return moves.sort((a, b) => b.score - a.score).slice(0, 40);
        }

        // Minimax algorithm with Alpha-Beta pruning
        // Minimax ç®—æ³•ç»“åˆ Alpha-Beta å‰ªæ
        function minimax(depth, alpha, beta, isMaximizingPlayer, player) {
            // Check transposition table, if this position has been calculated and the depth is sufficient, return the cached result directly
            // æ£€æŸ¥ç½®æ¢è¡¨ï¼Œå¦‚æœå·²è®¡ç®—è¿‡æ­¤å±€é¢ä¸”æ·±åº¦è¶³å¤Ÿï¼Œåˆ™ç›´æ¥è¿”å›ç¼“å­˜ç»“æœ
            const currentBoardHash = getBoardHash(gameBoard);
            const cachedResult = transpositionTable.get(currentBoardHash);
            if (cachedResult && cachedResult.depth >= depth) {
                return cachedResult;
            }

            // Reached search depth, evaluate the current board
            // è¾¾åˆ°æœç´¢æ·±åº¦ï¼Œè¯„ä¼°å½“å‰æ£‹ç›˜
            if (depth === 0) {
                const score = evaluateBoard(player);
                const result = { score: score, move: null };
                // Store result in transposition table
                // å­˜å‚¨ç»“æœåˆ°ç½®æ¢è¡¨
                transpositionTable.set(currentBoardHash, { score: score, depth: depth, move: null });
                return result;
            }
            
            const moves = getOrderedMoves(player);
            if (moves.length === 0) { // No moves available
                // æ²¡æœ‰å¯èµ°çš„æ­¥æ•°
                const result = { score: 0, move: null };
                transpositionTable.set(currentBoardHash, { score: 0, depth: depth, move: null });
                return result;
            }
            
            let bestMove = null;
            
            if (isMaximizingPlayer) { // Current is maximizing player (AI itself)
                // å½“å‰æ˜¯æœ€å¤§åŒ–ç©å®¶ï¼ˆAI è‡ªèº«ï¼‰
                let maxScore = -Infinity;
                for (const move of moves) {
                    gameBoard[move.x][move.y] = player; // Try placing a piece
                    if (checkWin(move.x, move.y, player)) { // If current move directly wins
                        gameBoard[move.x][move.y] = 0; // Undo the move
                        const result = { score: 100000, move: move };
                        transpositionTable.set(currentBoardHash, { score: 100000, depth: depth, move: move });
                        return result; // Return high score directly
                    }
                    // Recursively call minimax
                    // é€’å½’è°ƒç”¨ minimax
                    const result = minimax(depth - 1, alpha, beta, false, player === 1 ? 2 : 1);
                    gameBoard[move.x][move.y] = 0; // Undo the move
                    if (result.score > maxScore) {
                        maxScore = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, result.score); // Update alpha value
                    if (beta <= alpha) break; // Alpha-Beta pruning
                }
                const finalResult = { score: maxScore, move: bestMove };
                transpositionTable.set(currentBoardHash, { score: maxScore, depth: depth, move: bestMove });
                return finalResult;
            } else { // Current is minimizing player (opponent)
                // å½“å‰æ˜¯æœ€å°åŒ–ç©å®¶ï¼ˆå¯¹æ‰‹ï¼‰
                let minScore = Infinity;
                for (const move of moves) {
                    gameBoard[move.x][move.y] = player; // Try placing a piece
                    if (checkWin(move.x, move.y, player)) { // If opponent's current move directly wins
                        gameBoard[move.x][move.y] = 0; // Undo the move
                        const result = { score: -100000, move: move };
                        transpositionTable.set(currentBoardHash, { score: -100000, depth: depth, move: move });
                        return result; // Return low score directly
                    }
                    // Recursively call minimax
                    // é€’å½’è°ƒç”¨ minimax
                    const result = minimax(depth - 1, alpha, beta, true, player === 1 ? 2 : 1);
                    gameBoard[move.x][move.y] = 0; // Undo the move
                    if (result.score < minScore) {
                        minScore = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, result.score); // Update beta value
                    if (beta <= alpha) break; // Alpha-Beta pruning
                }
                const finalResult = { score: minScore, move: bestMove };
                transpositionTable.set(currentBoardHash, { score: minScore, depth: depth, move: bestMove });
                return finalResult;
            }
        }

        // Find a direct winning move
        // å¯»æ‰¾ç›´æ¥è·èƒœçš„èµ°æ³•
        function findWinningMove(player) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameBoard[i][j] === 0) {
                        gameBoard[i][j] = player;
                        if (checkWin(i, j, player)) {
                            gameBoard[i][j] = 0;
                            return { x: i, y: j };
                        }
                        gameBoard[i][j] = 0;
                    }
                }
            }
            return null;
        }

        // Get the best move
        // è·å–æœ€ä½³èµ°æ³•
        function getBestMove(currentPlayer, difficulty) {
            const config = difficultyConfig[difficulty];
            
            // First, check if there is a direct winning move
            // ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥è·èƒœçš„èµ°æ³•
            const winMove = findWinningMove(currentPlayer);
            if (winMove) return winMove;
            
            // Check if the opponent has a direct winning threat and block it
            // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰ç›´æ¥è·èƒœçš„å¨èƒï¼Œå¹¶è¿›è¡Œé˜»æ–­
            const opponent = currentPlayer === 1 ? 2 : 1;
            const blockMove = findWinningMove(opponent);
            if (blockMove) return blockMove;
            
            // Use Minimax algorithm for deep search
            // ä½¿ç”¨ Minimax ç®—æ³•è¿›è¡Œæ·±åº¦æœç´¢
            const result = minimax(config.searchDepth, -Infinity, Infinity, true, currentPlayer);
            if (result.move) {
                return result.move;
            }

            // If Minimax algorithm fails to find the best move (should not happen, as a fallback)
            // å¦‚æœ Minimax ç®—æ³•æœªèƒ½æ‰¾åˆ°æœ€ä½³èµ°æ³•ï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼Œä½œä¸ºåå¤‡ï¼‰
            const moves = getOrderedMoves(currentPlayer);
            return moves.length > 0 ? moves[0] : null;
        }

        // Listen for messages from the main thread
        // ç›‘å¬ä¸»çº¿ç¨‹çš„æ¶ˆæ¯
        self.onmessage = (e) => {
            const { board, currentPlayer, difficulty, moveHistory } = e.data;
            gameBoard = board; // Update Worker's board state

            let move;
            const config = difficultyConfig[difficulty];

            // Special handling for the opening, to prevent AI from always placing in the center
            // é’ˆå¯¹å¼€å±€çš„ç‰¹æ®Šå¤„ç†ï¼Œé¿å… AI æ€»æ˜¯ä¸‹åœ¨ä¸­å¿ƒç‚¹
            if (moveHistory.length === 1) {
                const playerFirstMove = moveHistory[0];
                const candidateOpeningMoves = [];
                const radius = 2; // Search for placement points within a radius around the player's first move
                // åœ¨ç©å®¶ç¬¬ä¸€æ­¥å‘¨å›´çš„åŠå¾„èŒƒå›´å†…å¯»æ‰¾è½å­ç‚¹
                for (let i = Math.max(0, playerFirstMove.x - radius); i <= Math.min(BOARD_SIZE - 1, playerFirstMove.x + radius); i++) {
                    for (let j = Math.max(0, playerFirstMove.y - radius); j <= Math.min(BOARD_SIZE - 1, playerFirstMove.y + radius); j++) {
                        if (gameBoard[i][j] === 0 && !(i === playerFirstMove.x && j === playerFirstMove.y)) {
                            candidateOpeningMoves.push({ x: i, y: j });
                        }
                    }
                }
                const center = Math.floor(BOARD_SIZE / 2);
                const maxDistanceFromCenter = 5; // Limit the distance of opening moves from the center
                // é™åˆ¶å¼€å±€èµ°æ³•è·ç¦»ä¸­å¿ƒçš„è·ç¦»
                const filteredCandidates = candidateOpeningMoves.filter(m => {
                    const distFromCenter = Math.max(Math.abs(m.x - center), Math.abs(m.y - center));
                    return distFromCenter <= maxDistanceFromCenter;
                });
                if (filteredCandidates.length > 0) {
                    // Randomly select one from the filtered candidates
                    // ä»ç­›é€‰å‡ºçš„å€™é€‰ä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
                    move = filteredCandidates[Math.floor(Math.random() * filteredCandidates.length)];
                } else {
                    // If no suitable opening move, fall back to Minimax
                    // å¦‚æœæ²¡æœ‰åˆé€‚çš„å¼€å±€èµ°æ³•ï¼Œåˆ™å›é€€åˆ° Minimax
                    move = getBestMove(currentPlayer, difficulty);
                }
            } else if (Math.random() < config.randomMoveChance) { // Random move chance (for increasing difficulty variation)
                // éšæœºèµ°å­æœºä¼šï¼ˆç”¨äºå¢åŠ éš¾åº¦å˜åŒ–ï¼‰
                const moves = getOrderedMoves(currentPlayer);
                move = moves.length > 0 ? moves[Math.floor(Math.random() * Math.min(moves.length, 5))] : null;
            } else {
                // Normally use Minimax algorithm to get the best move
                // æ­£å¸¸æƒ…å†µä¸‹ä½¿ç”¨ Minimax ç®—æ³•è·å–æœ€ä½³èµ°æ³•
                move = getBestMove(currentPlayer, difficulty);
            }
            
            // Send the result back to the main thread, including the player who made the move
            // å°†ç»“æœå‘é€å›ä¸»çº¿ç¨‹ï¼ŒåŒ…æ‹¬è¿›è¡Œè½å­çš„ç©å®¶
            self.postMessage({ move: move, player: currentPlayer });
        };
    </script>
    <!-- ================================================================= -->
    <!-- ======================= MAIN GAME SCRIPT ======================== -->
    <!-- ================================================================= -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            // æ¸¸æˆå¸¸é‡
            const BOARD_SIZE = 15;
            const INTERNAL_DRAWING_CELL_SIZE = 50;
            const INTERNAL_DRAWING_PIECE_SIZE = INTERNAL_DRAWING_CELL_SIZE * 0.85;
            const INTERNAL_DRAWING_BOARD_PADDING = INTERNAL_DRAWING_CELL_SIZE;
            
            const LOGICAL_CANVAS_WIDTH = (BOARD_SIZE - 1) * INTERNAL_DRAWING_CELL_SIZE + INTERNAL_DRAWING_BOARD_PADDING * 2;
            const LOGICAL_CANVAS_HEIGHT = LOGICAL_CANVAS_WIDTH;

            const devicePixelRatio = window.devicePixelRatio || 1;

            // Mobile auto-zoom/pan constants
            // ç§»åŠ¨ç«¯è‡ªåŠ¨ç¼©æ”¾/å¹³ç§»å¸¸é‡
            const IS_MOBILE = window.innerWidth < 768;
            const IDLE_TIMEOUT_MS = 5000; // 5 seconds inactivity timeout
            const INITIAL_MOBILE_VISIBLE_CELLS = 9; // Initial visible cells on mobile
            const OPTIMAL_VIEW_PADDING_CELLS = 1; // Additional padding cells for optimal view

            // Game state variables
            // æ¸¸æˆçŠ¶æ€å˜é‡
            let gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            let currentPlayer = 1; // 1: Black piece, 2: White piece
            let gameOver = false;
            let difficulty = 2; // 1: Easy, 2: Medium, 3: Hard
            let moveHistory = []; // Stores all move history
            let lastMovePosition = null; // Last move position
            let gameMode = 1; // 1: Player vs AI, 2: Player vs Player, 3: AI vs AI
            let gameCount = 1; // Game count
            let playerStartsWithBlack = true; // Does the player start with black?
            let undoChances = 0; // Undo chances
            let isAiThinking = false; // Is AI thinking?
            let isAnimatingZoom = false; // Is the board animating zoom?
            let aiPlayerRoles = {}; // AI player role names

            // Auto-zoom/pan related variables
            // è‡ªåŠ¨ç¼©æ”¾/å¹³ç§»ç›¸å…³å˜é‡
            let scale = 1.0;
            let translateX = 0;
            let translateY = 0;
            let isDragging = false;
            let lastPanX = 0;
            let lastPanY = 0;
            let initialPinchDistance = 0;
            let initialPinchScale = 1;
            let initialPinchMidX = 0;
            let initialPinchMidY = 0;
            let isGestureActive = false; // Is there an active user gesture?
            let initialTouchX = 0;
            let initialTouchY = 0;
            const tapThreshold = 10; // Tap threshold
            let idleTimer = null; // Idle timer
            let countdownTimer = null; // Countdown timer
            let countdownValue = 0; // Countdown value
            
            // DOM elements
            // DOM å…ƒç´ 
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const boardContainer = document.querySelector('.board-container');
            const currentPlayerIndicator = document.getElementById('player-indicator');
            const currentPlayerText = document.getElementById('player-text');
            const gameStatus = document.getElementById('game-status');
            const gameCountDisplay = document.getElementById('game-count');
            const winnerInfo = document.getElementById('winner-info');
            const winnerIndicator = document.getElementById('winner-indicator');
            const winnerText = document.getElementById('winnerText');
            const newGameBtn = document.getElementById('new-game');
            const undoBtn = document.getElementById('undo');
            const undoChancesDisplay = document.getElementById('undo-chances');
            const difficultyToggle = document.getElementById('difficulty-toggle');
            const difficultyText = document.getElementById('difficulty-text');
            const gameLog = document.getElementById('game-log');
            const modeToggle = document.getElementById('mode-toggle');
            const modeText = document.getElementById('mode-text');
            const winnerModal = document.getElementById('winner-modal');
            const winnerModalTitle = document.getElementById('winner-modal-title');
            const winnerModalMessage = document.getElementById('winner-modal-message');
            const closeModalBtn = document.querySelector('.close');
            const music = document.getElementById('music');
            const musicToggle = document.getElementById('music-toggle');
            const musicText = document.getElementById('music-text');
            const redeemCodeInput = document.getElementById('redeem-code-input');
            const countdownWindow = document.getElementById('countdown-window'); // Countdown window
            const countdownText = document.getElementById('countdown-text');     // Countdown text

            // Offscreen Canvas for optimized rendering performance
            // ç¦»å± Canvasï¼Œç”¨äºä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
            const backgroundCanvas = document.createElement('canvas');
            const backgroundCtx = backgroundCanvas.getContext('2d');
            const piecesCanvas = document.createElement('canvas');
            const piecesCtx = piecesCanvas.getContext('2d');

            // AI Web Worker
            // AI Web Worker
            let aiWorker;
            function createWorker() {
                try {
                    const workerScript = document.getElementById('ai-worker').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    const worker = new Worker(URL.createObjectURL(blob));

                    // Set up message and error handlers ONCE when the worker is created
                    // åœ¨ Worker åˆ›å»ºæ—¶ä¸€æ¬¡æ€§è®¾ç½®æ¶ˆæ¯å’Œé”™è¯¯å¤„ç†å™¨
                    worker.onmessage = (e) => {
                        const { move, player: aiPlayerWhoMoved } = e.data; // Destructure move and the player from worker's response
                        // ä» Worker çš„å“åº”ä¸­è§£æ„å‡ºè½å­å’Œè¿›è¡Œè½å­çš„ç©å®¶

                        isAiThinking = false;
                        gameStatus.classList.remove('thinking-status');

                        if (move && !gameOver) {
                            const {x, y} = move;
                            // Critical check: Ensure the spot is still empty before placing the piece
                            // å…³é”®æ£€æŸ¥ï¼šåœ¨æ”¾ç½®æ£‹å­ä¹‹å‰ï¼Œç¡®ä¿è¯¥ä½ç½®ä»ç„¶æ˜¯ç©ºçš„
                            if (gameBoard[x][y] !== 0) {
                                console.warn(`AI tried to place piece at (${x+1},${y+1}) but it's already occupied. Skipping this move.`);
                                logMessage(`AIå°è¯•åœ¨å·²å ç”¨çš„ä½ç½®(${x+1},${y+1})è½å­ï¼Œè·³è¿‡æ­¤æ­¥ã€‚`);
                                // If AI tried to move to an occupied spot, we still need to switch turn
                                // å¦‚æœ AI å°è¯•åœ¨å·²å ç”¨çš„ä½ç½®è½å­ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦åˆ‡æ¢å›åˆ
                                if (!gameOver) {
                                    currentPlayer = aiPlayerWhoMoved === 1 ? 2 : 1; // Still switch turn
                                    updateGameStatus();
                                    if (gameMode === 3) {
                                        setTimeout(() => aiMove(), 1000);
                                    }
                                }
                                resetIdleTimer();
                                return;
                            }

                            gameBoard[x][y] = aiPlayerWhoMoved; // Use the player from the worker's response
                            // ä½¿ç”¨ä» Worker å“åº”ä¸­è·å–çš„ç©å®¶æ¥æ”¾ç½®æ£‹å­
                            moveHistory.push({x, y, player: aiPlayerWhoMoved});
                            lastMovePosition = {x, y};
                            
                            const pieceColor = aiPlayerWhoMoved === 1 ? 'é»‘' : 'ç™½';
                            logMessage(`${getPlayerName(aiPlayerWhoMoved)}åœ¨(${x+1},${y+1})è½${pieceColor}å­`);

                            animatePiecePlacement(x, y, aiPlayerWhoMoved === 1 ? 'black' : 'white', () => {
                                updateDynamicZoom();
                                if (checkWin(x, y, aiPlayerWhoMoved)) {
                                    gameOver = true;
                                    const winnerMessage = `${getPlayerName(aiPlayerWhoMoved)}è·èƒœï¼`;
                                    updateGameStatus(winnerMessage);
                                    showWinnerModal(winnerMessage);
                                    return;
                                }
                                if (isBoardFull()) {
                                    gameOver = true;
                                    updateGameStatus('å¹³å±€ï¼');
                                    showWinnerModal('å¹³å±€ï¼');
                                    return;
                                }
                                if (!gameOver) {
                                    currentPlayer = aiPlayerWhoMoved === 1 ? 2 : 1; // Switch player based on who *just* moved
                                    // æ ¹æ®åˆšåˆšè½å­çš„ç©å®¶åˆ‡æ¢å›åˆ
                                }
                                updateGameStatus();
                                if (gameMode === 3 && !gameOver) {
                                    setTimeout(() => aiMove(), 1000);
                                }
                                resetIdleTimer();
                            });
                        } else if (!gameOver) {
                            console.warn("AI worker returned no move or game is already over.");
                            logMessage("AIæœªèƒ½æ‰¾åˆ°æœ‰æ•ˆè½å­ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚");
                            isAiThinking = false;
                            gameStatus.classList.remove('thinking-status');
                            updateGameStatus();
                            // If no move, still switch turn to avoid infinite loop if AI gets stuck
                            // å¦‚æœæ²¡æœ‰è½å­ï¼Œä»ç„¶åˆ‡æ¢å›åˆä»¥é¿å… AI å¡ä½å¯¼è‡´æ— é™å¾ªç¯
                            if (!gameOver) {
                                currentPlayer = aiPlayerWhoMoved === 1 ? 2 : 1; // Still switch turn
                                updateGameStatus();
                                if (gameMode === 3) {
                                    setTimeout(() => aiMove(), 1000);
                                }
                            }
                        }
                    };

                    worker.onerror = (e) => {
                        console.error(`Error from AI worker:`, e);
                        logMessage("AIè®¡ç®—å‡ºé”™ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚");
                        isAiThinking = false;
                        gameStatus.classList.remove('thinking-status');
                        updateGameStatus();
                    };

                    return worker;

                } catch (e) {
                    console.error("Failed to create Web Worker:", e);
                    logMessage("Error: Failed to initialize AI engine. Please refresh the page.");
                    return null;
                }
            }
            // Initial worker creation is moved to initGame()

            // AI difficulty configuration (for simulating thinking time in the main thread)
            // AI éš¾åº¦é…ç½®ï¼ˆç”¨äºä¸»çº¿ç¨‹çš„æ€è€ƒæ—¶é—´æ¨¡æ‹Ÿï¼‰
            const difficultyConfig = {
                1: { thinkTimeRange: [400, 1500] },
                2: { thinkTimeRange: [800, 3500] },
                3: { thinkTimeRange: [1000, 5500] }
            };

            // Set Canvas dimensions
            // è®¾ç½® Canvas å°ºå¯¸
            canvas.width = LOGICAL_CANVAS_WIDTH * devicePixelRatio;
            canvas.height = LOGICAL_CANVAS_HEIGHT * devicePixelRatio;
            backgroundCanvas.width = canvas.width;
            backgroundCanvas.height = canvas.height;
            piecesCanvas.width = canvas.width;
            piecesCanvas.height = canvas.height;
            
            ctx.scale(devicePixelRatio, devicePixelRatio);
            backgroundCtx.scale(devicePixelRatio, devicePixelRatio);
            piecesCtx.scale(devicePixelRatio, devicePixelRatio);

            // --- Main Thread Functions ---
            // --- ä¸»çº¿ç¨‹å‡½æ•° ---
            
            // Check for win
            // æ£€æŸ¥æ˜¯å¦è·èƒœ
            function checkWin(x, y, player) {
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
                for (const [dx, dy] of directions) {
                    let count = 1;
                    for (let i = 1; i < 5; i++) {
                        const nx = x + dx * i; const ny = y + dy * i;
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || gameBoard[nx][ny] !== player) break;
                        count++;
                    }
                    for (let i = 1; i < 5; i++) {
                        const nx = x - dx * i; const ny = y - dy * i;
                        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || gameBoard[nx][ny] !== player) break;
                        count++;
                    }
                    if (count >= 5) return true;
                }
                return false;
            }

            // Check if the board is full
            // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
            function isBoardFull() {
                return gameBoard.every(row => row.every(cell => cell !== 0));
            }

            // Calculate responsive display size
            // è®¡ç®—å“åº”å¼æ˜¾ç¤ºå°ºå¯¸
            function calculateResponsiveDisplaySize() {
                const container = document.querySelector('.board-area');
                const containerWidth = container.clientWidth;
                const maxDisplaySize = Math.min(containerWidth - 16, window.innerWidth - 32);
                
                canvas.style.width = `${maxDisplaySize}px`;
                canvas.style.height = `${maxDisplaySize}px`;
                canvas.dataset.initialScale = maxDisplaySize / LOGICAL_CANVAS_WIDTH;
                
                boardContainer.style.width = `${maxDisplaySize}px`;
                boardContainer.style.height = `${maxDisplaySize}px`;

                // If not mobile device or no moves yet, reset zoom and pan
                // å¦‚æœä¸æ˜¯ç§»åŠ¨è®¾å¤‡æˆ–è¿˜æ²¡æœ‰è½å­ï¼Œåˆ™é‡ç½®ç¼©æ”¾å’Œå¹³ç§»
                if (!IS_MOBILE || moveHistory.length === 0) {
                    scale = 1.0;
                    translateX = 0;
                    translateY = 0;
                    clampPan();
                    applyTransform();
                } else {
                    // Mobile devices dynamically adjust zoom
                    // ç§»åŠ¨è®¾å¤‡åˆ™åŠ¨æ€è°ƒæ•´ç¼©æ”¾
                    updateDynamicZoom(); 
                }
            }

            // Apply Canvas transformations
            // åº”ç”¨ Canvas å˜æ¢
            function applyTransform() {
                canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }
            
            // Initialize game
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                // Terminate existing worker if it exists, and create a new one
                // ç»ˆæ­¢ç°æœ‰ workerï¼Œå¦‚æœå­˜åœ¨ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„
                if (aiWorker) {
                    aiWorker.terminate();
                }
                aiWorker = createWorker(); // Create a new worker for the new game session

                calculateResponsiveDisplaySize(); 
                gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                gameOver = false;
                moveHistory = [];
                lastMovePosition = null;
                isAiThinking = false;
                isAnimatingZoom = false;
                
                clearGameLog();
                logMessage(`ç¬¬${gameCount}å±€å¼€å§‹`);
                
                drawStaticBoard(); // Draw static board background
                updatePiecesCanvas(); // Update pieces Canvas

                // Set current player based on game mode and who starts with black
                // æ ¹æ®æ¸¸æˆæ¨¡å¼å’Œæ‰§é»‘å…ˆæ‰‹æ–¹è®¾ç½®å½“å‰ç©å®¶
                currentPlayer = 1; // Always start with black piece's turn (1 for black, 2 for white)

                if (gameMode === 3) { // AI vs AI mode
                    if (gameCount % 2 !== 0) {
                        aiPlayerRoles = { 1: { name: 'å¼€å…ƒ', color: 'é»‘' }, 2: { name: 'Kaiyuan AI', color: 'ç™½' } };
                        logMessage('å¼€å…ƒæ‰§é»‘å…ˆæ‰‹');
                    } else {
                        aiPlayerRoles = { 1: { name: 'Kaiyuan AI', color: 'é»‘' }, 2: { name: 'å¼€å…ƒ', color: 'ç™½' } };
                        logMessage('Kaiyuan AIæ‰§é»‘å…ˆæ‰‹');
                    }
                    updateGameStatus();
                    // Add a short delay for the first AI vs AI move to ensure UI is ready
                    // ä¸º AI vs AI çš„ç¬¬ä¸€æ­¥æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œç¡®ä¿ UI å‡†å¤‡å°±ç»ª
                    setTimeout(() => aiMove(), 1000); 
                } else if (IS_MOBILE) { // Initial zoom for mobile
                    // ç§»åŠ¨ç«¯åˆå§‹ç¼©æ”¾
                    const optimalView = calculateOptimalView({ visibleCells: INITIAL_MOBILE_VISIBLE_CELLS });
                    scale = optimalView.scale;
                    translateX = optimalView.translateX;
                    translateY = optimalView.translateY;
                    clampPan();
                    applyTransform();
                } else { // Reset zoom for non-mobile
                    // éç§»åŠ¨ç«¯é‡ç½®ç¼©æ”¾
                    scale = 1.0; translateX = 0; translateY = 0;
                    clampPan(); applyTransform();
                }

                if (gameMode === 1) { // Player vs AI mode
                    // ç©å®¶ vs AI æ¨¡å¼
                    if (playerStartsWithBlack) { // Human is black
                        logMessage('ç©å®¶æ‰§é»‘å…ˆæ‰‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­');
                    } else { // AI is black
                        logMessage('å¼€å…ƒæ‰§é»‘å…ˆæ‰‹');
                        setTimeout(() => { if (!gameOver) aiMove(); }, 500);
                    }
                } else if (gameMode === 2) { // Player vs Player mode
                    // ç©å®¶ vs ç©å®¶ æ¨¡å¼
                    if (playerStartsWithBlack) { // Player 1 is black
                        logMessage('ç©å®¶1æ‰§é»‘å…ˆæ‰‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­');
                    } else { // Player 2 is black
                        logMessage('ç©å®¶2æ‰§é»‘å…ˆæ‰‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­');
                    }
                }
                
                if (gameMode !== 3) updateGameStatus(); 

                winnerModal.style.display = 'none';
                updateUndoChancesDisplay();
                drawBoard();
                resetIdleTimer(); // Reset idle timer when game initializes
            }

            // Draw static board background
            // ç»˜åˆ¶é™æ€æ£‹ç›˜èƒŒæ™¯
            function drawStaticBoard() {
                backgroundCtx.clearRect(0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                const boardGradient = backgroundCtx.createLinearGradient(0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                boardGradient.addColorStop(0, '#DEB887'); boardGradient.addColorStop(1, '#C19A6B');
                backgroundCtx.fillStyle = boardGradient;
                backgroundCtx.fillRect(0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                backgroundCtx.strokeStyle = '#8B4513'; backgroundCtx.lineWidth = 1.5;

                for (let i = 0; i < BOARD_SIZE; i++) {
                    backgroundCtx.beginPath();
                    backgroundCtx.moveTo(INTERNAL_DRAWING_BOARD_PADDING, INTERNAL_DRAWING_BOARD_PADDING + i * INTERNAL_DRAWING_CELL_SIZE);
                    backgroundCtx.lineTo(LOGICAL_CANVAS_WIDTH - INTERNAL_DRAWING_BOARD_PADDING, INTERNAL_DRAWING_BOARD_PADDING + i * INTERNAL_DRAWING_CELL_SIZE);
                    backgroundCtx.stroke();
                    backgroundCtx.beginPath();
                    backgroundCtx.moveTo(INTERNAL_DRAWING_BOARD_PADDING + i * INTERNAL_DRAWING_CELL_SIZE, INTERNAL_DRAWING_BOARD_PADDING);
                    backgroundCtx.lineTo(INTERNAL_DRAWING_BOARD_PADDING + i * INTERNAL_DRAWING_CELL_SIZE, LOGICAL_CANVAS_HEIGHT - INTERNAL_DRAWING_BOARD_PADDING);
                    backgroundCtx.stroke();
                }
                const starPoints = [{x: 3, y: 3}, {x: 3, y: 11}, {x: 7, y: 7}, {x: 11, y: 3}, {x: 11, y: 11}];
                starPoints.forEach(point => drawStarPoint(point.x, point.y, backgroundCtx));
            }

            // Update pieces Canvas
            // æ›´æ–°æ£‹å­ Canvas
            function updatePiecesCanvas() {
                piecesCtx.clearRect(0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (gameBoard[i][j] === 1) drawPiece(i, j, 'black', 1, piecesCtx);
                        else if (gameBoard[i][j] === 2) drawPiece(i, j, 'white', 1, piecesCtx);
                    }
                }
            }
            
            // Draw board (including background and pieces)
            // ç»˜åˆ¶æ£‹ç›˜ï¼ˆåŒ…æ‹¬èƒŒæ™¯å’Œæ£‹å­ï¼‰
            function drawBoard() {
                ctx.clearRect(0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                ctx.drawImage(backgroundCanvas, 0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                ctx.drawImage(piecesCanvas, 0, 0, LOGICAL_CANVAS_WIDTH, LOGICAL_CANVAS_HEIGHT);
                if (lastMovePosition) drawLastMoveMarker(lastMovePosition.x, lastMovePosition.y);
            }
            
            // Draw star point
            // ç»˜åˆ¶æ˜Ÿä½
            function drawStarPoint(x, y, targetCtx) {
                const centerX = INTERNAL_DRAWING_BOARD_PADDING + x * INTERNAL_DRAWING_CELL_SIZE;
                const centerY = INTERNAL_DRAWING_BOARD_PADDING + y * INTERNAL_DRAWING_CELL_SIZE;
                const radius = 4;
                targetCtx.beginPath();
                targetCtx.arc(centerX + 1, centerY + 1, radius, 0, 2 * Math.PI);
                targetCtx.fillStyle = 'rgba(0, 0, 0, 0.3)'; targetCtx.fill();
                targetCtx.beginPath();
                targetCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                targetCtx.fillStyle = '#8B4513'; targetCtx.fill();
            }
            
            // Draw piece
            // ç»˜åˆ¶æ£‹å­
            function drawPiece(x, y, color, pieceScale = 1, targetCtx = ctx) {
                const centerX = INTERNAL_DRAWING_BOARD_PADDING + x * INTERNAL_DRAWING_CELL_SIZE;
                const centerY = INTERNAL_DRAWING_BOARD_PADDING + y * INTERNAL_DRAWING_CELL_SIZE;
                const currentPieceSize = INTERNAL_DRAWING_PIECE_SIZE * pieceScale;
                targetCtx.beginPath();
                targetCtx.arc(centerX + 2 * pieceScale, centerY + 2 * pieceScale, currentPieceSize / 2, 0, 2 * Math.PI);
                targetCtx.fillStyle = 'rgba(0, 0, 0, 0.25)'; targetCtx.fill();
                targetCtx.beginPath();
                targetCtx.arc(centerX, centerY, currentPieceSize / 2, 0, 2 * Math.PI);
                const gradient = targetCtx.createRadialGradient(
                    centerX - currentPieceSize / 4, centerY - currentPieceSize / 4, currentPieceSize / 10,
                    centerX, centerY, currentPieceSize / 2
                );
                if (color === 'white') {
                    gradient.addColorStop(0, '#FFFFFF'); gradient.addColorStop(0.7, '#F0F0F0'); gradient.addColorStop(1, '#E0E0E0');
                    targetCtx.strokeStyle = '#D9D9D9';
                } else {
                    gradient.addColorStop(0, '#404040'); gradient.addColorStop(0.7, '#1A1A1A'); gradient.addColorStop(1, '#000000');
                    targetCtx.strokeStyle = '#333333';
                }
                targetCtx.fillStyle = gradient; targetCtx.fill();
                targetCtx.lineWidth = 1; targetCtx.stroke();
            }

            // Piece placement animation
            // æ£‹å­æ”¾ç½®åŠ¨ç”»
            function animatePiecePlacement(x, y, playerColor, callback) {
                let animationStartTime = null;
                const animationDuration = 200;
                function animate(currentTime) {
                    if (!animationStartTime) animationStartTime = currentTime;
                    const elapsedTime = currentTime - animationStartTime;
                    const progress = Math.min(elapsedTime / animationDuration, 1);
                    const pieceAnimationScale = 0.5 + (0.5 * progress); // Scale from small to large
                    drawBoard(); // Redraw board every animation frame
                    drawPiece(x, y, playerColor, pieceAnimationScale, ctx); // Draw animated piece
                    if (progress < 1) requestAnimationFrame(animate);
                    else {
                        updatePiecesCanvas(); // Update offscreen Canvas after animation
                        drawBoard(); // Final draw
                        if (callback) callback();
                    }
                }
                requestAnimationFrame(animate);
            }
            
            // Draw last move marker
            // ç»˜åˆ¶æœ€åä¸€æ­¥æ ‡è®°
            function drawLastMoveMarker(x, y) {
                const centerX = INTERNAL_DRAWING_BOARD_PADDING + x * INTERNAL_DRAWING_CELL_SIZE;
                const centerY = INTERNAL_DRAWING_BOARD_PADDING + y * INTERNAL_DRAWING_CELL_SIZE;
                const radius = INTERNAL_DRAWING_PIECE_SIZE / 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF4500'; // Orange-red
                ctx.shadowColor = 'rgba(255, 69, 0, 0.7)'; ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; // Clear shadow
            }
            
            // Handle player move
            // å¤„ç†ç©å®¶è½å­
            function handlePlayerMove(x, y) {
                // Check if game is over, position has a piece, is AI vs AI mode, is animating zoom, or AI is thinking
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸã€å½“å‰ä½ç½®æ˜¯å¦æœ‰æ£‹å­ã€æ˜¯å¦ä¸º AI vs AI æ¨¡å¼ã€æ˜¯å¦æ­£åœ¨è¿›è¡Œç¼©æ”¾åŠ¨ç”»æˆ– AI æ­£åœ¨æ€è€ƒ
                if (gameOver || gameBoard[x][y] !== 0 || gameMode === 3 || isAnimatingZoom || isAiThinking) {
                    if (isAnimatingZoom) logMessage('æ­£åœ¨è¿›è¡Œçª—å£ç¼©æ”¾åŠ¨ç”»ï¼Œè¯·ç¨å€™å†è½å­ã€‚');
                    if (isAiThinking) logMessage('AIæ­£åœ¨æ€è€ƒï¼Œè¯·ç¨å€™ã€‚');
                    return;
                }
                
                // Check if it's the player's turn
                // æ£€æŸ¥æ˜¯å¦è½®åˆ°ç©å®¶è½å­
                const isPlayerTurn = (gameMode === 1 && ((playerStartsWithBlack && currentPlayer === 1) || (!playerStartsWithBlack && currentPlayer === 2))) || (gameMode === 2);
                if (!isPlayerTurn) return;
                
                gameBoard[x][y] = currentPlayer; // Place piece
                moveHistory.push({x, y, player: currentPlayer}); // Record move history
                lastMovePosition = {x, y}; // Update last move position
                
                const playerName = getPlayerName(currentPlayer);
                const pieceColor = currentPlayer === 1 ? 'é»‘' : 'ç™½';
                logMessage(`${playerName}åœ¨(${x+1},${y+1})è½${pieceColor}å­`);
                
                // Play piece placement animation
                // æ’­æ”¾æ£‹å­æ”¾ç½®åŠ¨ç”»
                animatePiecePlacement(x, y, currentPlayer === 1 ? 'black' : 'white', () => {
                    updateDynamicZoom(); // Update board view (zoom and pan) after placing piece
                    if (checkWin(x, y, currentPlayer)) { // Check for win
                        gameOver = true;
                        const winnerMessage = `${playerName}è·èƒœï¼`;
                        updateGameStatus(winnerMessage);
                        logMessage(`æ­å–œï¼Œ${winnerMessage}`);
                        showWinnerModal(winnerMessage);
                        return;
                    }
                    if (isBoardFull()) { // Check for draw
                        gameOver = true;
                        updateGameStatus('å¹³å±€ï¼');
                        logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                        showWinnerModal('å¹³å±€ï¼');
                        return;
                    }
                    currentPlayer = currentPlayer === 1 ? 2 : 1; // Switch player
                    updateGameStatus();
                    if (gameMode === 1) { // If Player vs AI mode, it's AI's turn
                        const isAiTurn = (playerStartsWithBlack && currentPlayer === 2) || (!playerStartsWithBlack && currentPlayer === 1);
                        if (isAiTurn) aiMove();
                    }
                    resetIdleTimer(); // Reset idle timer after player action
                });
            }
            
            // AI move logic
            // AI è½å­é€»è¾‘
            function aiMove() {
                if (gameOver || isAiThinking) {
                    return;
                }
                
                isAiThinking = true; // Set AI thinking flag
                
                const currentAiPlayer = currentPlayer; // Capture current player for this move
                const aiName = getPlayerName(currentAiPlayer);
                updateGameStatus(`${aiName} ğŸ’­`); // Update game status to AI thinking
                gameStatus.classList.add('thinking-status'); // Add thinking animation

                const config = difficultyConfig[difficulty];
                // Simulate AI thinking time
                // æ¨¡æ‹Ÿ AI æ€è€ƒæ—¶é—´
                const thinkTime = config.thinkTimeRange[0] + Math.random() * (config.thinkTimeRange[1] - config.thinkTimeRange[0]);

                // After simulating thinking time, send board data to Web Worker for calculation
                // åœ¨æ¨¡æ‹Ÿæ€è€ƒæ—¶é—´åï¼Œå°†æ£‹ç›˜æ•°æ®å‘é€ç»™ Web Worker è¿›è¡Œè®¡ç®—
                setTimeout(() => {
                    aiWorker.postMessage({
                        board: gameBoard,
                        currentPlayer: currentAiPlayer, // Pass the player for whom the move is being calculated
                        difficulty: difficulty,
                        moveHistory: moveHistory
                    });
                }, thinkTime);
            }
            
            // Get player name
            // è·å–ç©å®¶åç§°
            function getPlayerName(player) {
                if (gameMode === 2) { // Player vs Player
                    // 'player' here is the piece color (1 for black, 2 for white)
                    // 'playerStartsWithBlack' determines if Player 1 is black or Player 2 is black
                    if (playerStartsWithBlack) { // Player 1 is black, Player 2 is white
                        return player === 1 ? 'ç©å®¶1' : 'ç©å®¶2';
                    } else { // Player 2 is black, Player 1 is white
                        return player === 1 ? 'ç©å®¶2' : 'ç©å®¶1';
                    }
                }
                if (gameMode === 3) { // AI vs AI
                    if (aiPlayerRoles && aiPlayerRoles[player]) {
                        const role = aiPlayerRoles[player];
                        return `${role.name} (${role.color})`;
                    }
                    return `AI Player ${player}`;
                }
                // Player vs AI mode
                // ç©å®¶ vs AI æ¨¡å¼
                // 'player' here refers to the piece color (1 for black, 2 for white)
                // We need to know who is playing which color based on playerStartsWithBlack
                if (playerStartsWithBlack) { // Human is black, AI is white
                    return player === 1 ? 'ç©å®¶' : 'å¼€å…ƒ';
                } else { // AI is black, Human is white
                    return player === 1 ? 'å¼€å…ƒ' : 'ç©å®¶';
                }
            }
            
            // Update game status display
            // æ›´æ–°æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
            function updateGameStatus(message) {
                gameCountDisplay.textContent = `ç¬¬ ${gameCount} å±€`;
                if (message) {
                    gameStatus.textContent = message;
                    if (gameOver) {
                        winnerInfo.classList.remove('hidden');
                        const winningPlayer = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1].player : null;
                        if (winningPlayer !== null) {
                            let winnerPieceColor = winningPlayer === 1 ? 'black' : 'white';
                            let winnerDisplayName = getPlayerName(winningPlayer);
                            winnerIndicator.className = `piece ${winnerPieceColor}`;
                            winnerText.textContent = winnerDisplayName;
                        } else {
                            winnerInfo.classList.add('hidden');
                        }
                    }
                } else {
                    gameStatus.textContent = 'æ¸¸æˆè¿›è¡Œä¸­';
                    winnerInfo.classList.add('hidden');
                    let currentPieceColor = currentPlayer === 1 ? 'black' : 'white';
                    let currentDisplayName = getPlayerName(currentPlayer); // This will correctly get 'ç©å®¶1' or 'ç©å®¶2'
                    currentPlayerIndicator.className = `piece ${currentPieceColor}`;
                    currentPlayerText.textContent = currentDisplayName;
                }
            }
            
            // Start new game
            // å¼€å§‹æ–°æ¸¸æˆ
            function startNewGame() {
                gameCount++;
                // Toggle who starts with black for Player vs AI and Player vs Player modes
                // ä»…åœ¨ç©å®¶ vs AI å’Œç©å®¶ vs ç©å®¶ æ¨¡å¼ä¸‹äº¤æ¢å…ˆæ‰‹æ£‹å­é¢œè‰²
                if (gameMode === 1 || gameMode === 2) { // Apply to both P vs AI and P vs P
                    playerStartsWithBlack = !playerStartsWithBlack;
                }
                initGame();
            }
            
            // Log game message
            // è®°å½•æ¸¸æˆæ—¥å¿—
            function logMessage(message) {
                const logEntry = document.createElement('p');
                logEntry.textContent = message;
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight; // Auto-scroll to bottom
            }
            
            // Clear game log
            // æ¸…ç©ºæ¸¸æˆæ—¥å¿—
            function clearGameLog() { gameLog.innerHTML = ''; }
            // Show winner modal
            // æ˜¾ç¤ºè·èƒœæ¨¡æ€æ¡†
            function showWinnerModal(message) {
                winnerModalTitle.textContent = 'æ¸¸æˆç»“æŸ';
                winnerModalMessage.textContent = message;
                winnerModal.style.display = 'block';
            }
            // Update undo chances display
            // æ›´æ–°æ‚”æ£‹æœºä¼šæ˜¾ç¤º
            function updateUndoChancesDisplay() { undoChancesDisplay.textContent = undoChances; }
            // Handle redeem code
            // å¤„ç†å…‘æ¢ç 
            function handleRedeemCode() {
                const code = redeemCodeInput.value.trim().toLowerCase();
                if (code === 'kaiyuan') {
                    undoChances++;
                    logMessage('æˆåŠŸå…‘æ¢1æ¬¡æ‚”æ£‹æœºä¼šï¼');
                    updateUndoChancesDisplay();
                } else {
                    logMessage('å…‘æ¢ç æ— æ•ˆã€‚');
                }
                redeemCodeInput.value = '';
            }
            
            // --- Zoom, Pan, and Auto-fit Logic ---
            // --- ç¼©æ”¾ã€å¹³ç§»å’Œè‡ªåŠ¨é€‚åº”é€»è¾‘ ---
            function clampPan() {
                const initialScaleFactor = parseFloat(canvas.dataset.initialScale) || 1;
                const currentDisplayWidth = LOGICAL_CANVAS_WIDTH * scale * initialScaleFactor;
                const currentDisplayHeight = LOGICAL_CANVAS_HEIGHT * scale * initialScaleFactor;
                const containerWidth = boardContainer.clientWidth;
                const containerHeight = boardContainer.clientHeight;

                let minXBound = containerWidth - currentDisplayWidth;
                let maxXBound = 0;
                let minYBound = containerHeight - currentDisplayHeight;
                let maxYBound = 0;

                if (currentDisplayWidth < containerWidth) {
                    minXBound = (containerWidth - currentDisplayWidth) / 2;
                    maxXBound = minXBound;
                }
                if (currentDisplayHeight < containerHeight) {
                    minYBound = (containerHeight - currentDisplayHeight) / 2;
                    maxYBound = minYBound;
                }
                
                translateX = Math.max(minXBound, Math.min(maxXBound, translateX));
                translateY = Math.max(minYBound, Math.min(maxYBound, translateY));
            }

            // Check if board area is roughly in view
            // æ£€æŸ¥æ£‹ç›˜åŒºåŸŸæ˜¯å¦å¤§è‡´åœ¨è§†çª—å†…
            function isBoardAreaInView() {
                const rect = boardContainer.getBoundingClientRect();
                // If at least 80% of the board area height is visible, and it's not scrolled too far horizontally, consider it in view
                // å¦‚æœæ£‹ç›˜åŒºåŸŸè‡³å°‘ 80% çš„é«˜åº¦å¯è§ï¼Œå¹¶ä¸”æ°´å¹³æ–¹å‘æ²¡æœ‰æ»šåŠ¨å¤ªè¿œï¼Œåˆ™è®¤ä¸ºåœ¨è§†å›¾ä¸­
                const verticalThreshold = rect.height * 0.2; // 20% from top/bottom
                const horizontalThreshold = rect.width * 0.2; // 20% from left/right

                return (
                    rect.top >= -verticalThreshold &&
                    rect.bottom <= (window.innerHeight + verticalThreshold) &&
                    rect.left >= -horizontalThreshold &&
                    rect.right <= (window.innerWidth + horizontalThreshold)
                );
            }

            // Reset idle timer and hide countdown window
            // é‡ç½®ç©ºé—²è®¡æ—¶å™¨å¹¶éšè—å€’è®¡æ—¶çª—å£
            function resetIdleTimer() {
                clearTimeout(idleTimer);
                clearInterval(countdownTimer);
                countdownWindow.classList.remove('show');
                if (IS_MOBILE) { // Only set idle timer on mobile devices
                    // ä»…åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šè®¾ç½®ç©ºé—²è®¡æ—¶å™¨
                    idleTimer = setTimeout(startCountdown, IDLE_TIMEOUT_MS);
                }
            }

            // Start auto-scroll countdown
            // å¯åŠ¨è‡ªåŠ¨æ»šåŠ¨å€’è®¡æ—¶
            function startCountdown() {
                // If not mobile device, or active gesture, or animating zoom, or game is over, do not auto-scroll
                // å¦‚æœä¸æ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œæˆ–æœ‰æ´»è·ƒæ‰‹åŠ¿ï¼Œæˆ–æ­£åœ¨è¿›è¡Œç¼©æ”¾åŠ¨ç”»ï¼Œæˆ–æ¸¸æˆå·²ç»“æŸï¼Œåˆ™ä¸è‡ªåŠ¨æ»šåŠ¨
                if (!IS_MOBILE || isGestureActive || isAnimatingZoom || gameOver) return; 
                
                // If board area is already in view, do not start countdown
                // å¦‚æœæ£‹ç›˜åŒºåŸŸå·²åœ¨è§†å›¾ä¸­ï¼Œåˆ™ä¸å¯åŠ¨å€’è®¡æ—¶
                if (isBoardAreaInView()) {
                    console.log("Board area is already in view, skipping auto-scroll countdown.");
                    return;
                }

                countdownValue = 3; // Start countdown from 3 seconds
                countdownText.textContent = `è‡ªåŠ¨æ»šåŠ¨è‡³æ£‹ç›˜ï¼š${countdownValue}s`;
                countdownWindow.classList.add('show');

                countdownTimer = setInterval(() => {
                    countdownValue--;
                    if (countdownValue > 0) {
                        countdownText.textContent = `è‡ªåŠ¨æ»šåŠ¨è‡³æ£‹ç›˜ï¼š${countdownValue}s`;
                    } else {
                        clearInterval(countdownTimer);
                        countdownWindow.classList.remove('show');
                        startAutoFit(); // Trigger auto-scroll after countdown
                    }
                }, 1000);
            }

            // Get piece bounding box
            // è·å–æ£‹å­è¾¹ç•Œæ¡†
            function getPieceBoundingBox() {
                if (moveHistory.length === 0) {
                    const mid = Math.floor(BOARD_SIZE / 2);
                    return { minX: mid, maxX: mid, minY: mid, maxY: mid };
                }
                let minX = BOARD_SIZE, maxX = -1, minY = BOARD_SIZE, maxY = -1;
                moveHistory.forEach(move => {
                    minX = Math.min(minX, move.x); maxX = Math.max(maxX, move.x);
                    minY = Math.min(minY, move.y); maxY = Math.max(maxY, move.y);
                });
                return { minX, maxX, minY, maxY };
            }

            // Calculate optimal view (zoom and pan)
            // è®¡ç®—æœ€ä½³è§†å›¾ï¼ˆç¼©æ”¾å’Œä½ç§»ï¼‰
            function calculateOptimalView(options = {}) {
                const initialScaleFactor = parseFloat(canvas.dataset.initialScale);
                const containerWidth = boardContainer.clientWidth;
                const containerHeight = boardContainer.clientHeight;
                let contentLogicalWidth, contentLogicalHeight, centerLogicalX, centerLogicalY;

                if (options.targetCenter && options.visibleCells) {
                    // Calculate view based on target center point
                    // ä»¥ç›®æ ‡ä¸­å¿ƒç‚¹ä¸ºåŸºå‡†è®¡ç®—è§†å›¾
                    const targetVisibleCells = options.visibleCells;
                    contentLogicalWidth = targetVisibleCells * INTERNAL_DRAWING_CELL_SIZE;
                    contentLogicalHeight = targetVisibleCells * INTERNAL_DRAWING_CELL_SIZE;
                    const targetViewLogicalX = options.targetCenter.x - (targetVisibleCells / 2);
                    const targetViewLogicalY = options.targetCenter.y - (targetVisibleCells / 2);
                    centerLogicalX = INTERNAL_DRAWING_BOARD_PADDING + (targetViewLogicalX + targetVisibleCells / 2) * INTERNAL_DRAWING_CELL_SIZE;
                    centerLogicalY = INTERNAL_DRAWING_BOARD_PADDING + (targetViewLogicalY + targetVisibleCells / 2) * INTERNAL_DRAWING_CELL_SIZE;
                } else if (options.boundingBox) {
                    // Calculate view based on piece bounding box
                    // æ ¹æ®æ£‹å­è¾¹ç•Œæ¡†è®¡ç®—è§†å›¾
                    const { minX, maxX, minY, maxY } = options.boundingBox;
                    const paddedMinX = Math.max(0, minX - OPTIMAL_VIEW_PADDING_CELLS);
                    const paddedMaxX = Math.min(BOARD_SIZE - 1, maxX + OPTIMAL_VIEW_PADDING_CELLS);
                    const paddedMinY = Math.max(0, minY - OPTIMAL_VIEW_PADDING_CELLS);
                    const paddedMaxY = Math.min(BOARD_SIZE - 1, maxY + OPTIMAL_VIEW_PADDING_CELLS);
                    contentLogicalWidth = (paddedMaxX - paddedMinX + 1) * INTERNAL_DRAWING_CELL_SIZE;
                    contentLogicalHeight = (paddedMaxY - paddedMinY + 1) * INTERNAL_DRAWING_CELL_SIZE;
                    centerLogicalX = INTERNAL_DRAWING_BOARD_PADDING + ((paddedMinX + paddedMaxX) / 2) * INTERNAL_DRAWING_CELL_SIZE;
                    centerLogicalY = INTERNAL_DRAWING_BOARD_PADDING + ((paddedMinY + paddedMaxY) / 2) * INTERNAL_DRAWING_CELL_SIZE;
                } else {
                    // Default initial view
                    // é»˜è®¤åˆå§‹è§†å›¾
                    contentLogicalWidth = INITIAL_MOBILE_VISIBLE_CELLS * INTERNAL_DRAWING_CELL_SIZE;
                    contentLogicalHeight = INITIAL_MOBILE_VISIBLE_CELLS * INTERNAL_DRAWING_CELL_SIZE;
                    centerLogicalX = LOGICAL_CANVAS_WIDTH / 2;
                    centerLogicalY = LOGICAL_CANVAS_HEIGHT / 2;
                }

                let newScale = Math.min(containerWidth / (contentLogicalWidth * initialScaleFactor), containerHeight / (contentLogicalHeight * initialScaleFactor));
                newScale = Math.max(1.0, Math.min(newScale, 2.5)); // Limit zoom range
                const targetDisplayCenterX = centerLogicalX * newScale * initialScaleFactor;
                const targetDisplayCenterY = centerLogicalY * newScale * initialScaleFactor;
                const newTranslateX = containerWidth / 2 - targetDisplayCenterX;
                const newTranslateY = containerHeight / 2 - targetDisplayCenterY;
                return { scale: newScale, translateX: newTranslateX, translateY: newTranslateY };
            }

            // Animate transition to target view
            // åŠ¨ç”»è¿‡æ¸¡åˆ°ç›®æ ‡è§†å›¾
            function animateToView(targetScale, targetX, targetY) {
                isAnimatingZoom = true; // Set animating flag, prevent player from placing pieces
                scale = targetScale; translateX = targetX; translateY = targetY;
                clampPan(); // Limit pan range
                applyTransform(); // Apply transformation
                // Reset flag after animation
                // åŠ¨ç”»ç»“æŸåé‡ç½®æ ‡å¿—
                setTimeout(() => { isAnimatingZoom = false; }, 600);
            }

            // Update dynamic zoom (mobile)
            // æ›´æ–°åŠ¨æ€ç¼©æ”¾ï¼ˆç§»åŠ¨ç«¯ï¼‰
            function updateDynamicZoom() {
                if (!IS_MOBILE) {
                    animateToView(1.0, 0, 0); // Non-mobile always maintain default view
                    return;
                }
                let optimalView;
                // Improved logic: When the number of pieces exceeds 2 steps, prioritize displaying the global view of all pieces
                // æ”¹è¿›é€»è¾‘ï¼šå½“æ£‹å­æ•°é‡è¶…è¿‡2æ­¥æ—¶ï¼Œä¼˜å…ˆæ˜¾ç¤ºæ‰€æœ‰æ£‹å­çš„å…¨å±€è§†å›¾
                if (moveHistory.length > 2) { 
                    const boundingBox = getPieceBoundingBox();
                    optimalView = calculateOptimalView({ boundingBox: boundingBox });
                } else if (lastMovePosition) {
                    // For the first few moves, still focus on the last move point
                    // å¯¹äºå¼€å±€å‰å‡ æ­¥ï¼Œä»ç„¶èšç„¦äºæœ€åè½å­ç‚¹
                    optimalView = calculateOptimalView({ targetCenter: lastMovePosition, visibleCells: 8 });
                } else {
                    // Initial state or no pieces
                    // åˆå§‹çŠ¶æ€æˆ–æ²¡æœ‰æ£‹å­æ—¶
                    optimalView = calculateOptimalView({ visibleCells: INITIAL_MOBILE_VISIBLE_CELLS });
                }
                animateToView(optimalView.scale, optimalView.translateX, optimalView.translateY);
            }

            // Auto-fit board view (called after countdown)
            // è‡ªåŠ¨é€‚åº”æ£‹ç›˜è§†å›¾ï¼ˆåœ¨å€’è®¡æ—¶åè°ƒç”¨ï¼‰
            function startAutoFit() {
                // If not mobile device, or active gesture, or animating zoom, or game is over, do not auto-fit
                // å¦‚æœä¸æ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œæˆ–æœ‰æ´»è·ƒæ‰‹åŠ¿ï¼Œæˆ–æ­£åœ¨è¿›è¡Œç¼©æ”¾åŠ¨ç”»ï¼Œæˆ–æ¸¸æˆå·²ç»“æŸï¼Œåˆ™ä¸è‡ªåŠ¨é€‚åº”
                if (!IS_MOBILE || isGestureActive || isAnimatingZoom || gameOver) return;
                const boundingBox = getPieceBoundingBox(); // Get piece bounding box
                const optimalView = calculateOptimalView({ boundingBox: boundingBox }); // Calculate optimal view
                animateToView(optimalView.scale, optimalView.translateX, optimalView.translateY); // Animate transition
                // Scroll to board area
                // æ»šåŠ¨åˆ°æ£‹ç›˜åŒºåŸŸ
                document.querySelector('.board-area').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Calculate distance between two points
            // è®¡ç®—ä¸¤ç‚¹è·ç¦»
            function getDistance(t1, t2) { return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2)); }
            // Calculate midpoint of two points
            // è®¡ç®—ä¸¤ç‚¹ä¸­ç‚¹
            function getMidpoint(t1, t2) { return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 }; }

            // --- Event Listeners and Initialization ---
            // --- äº‹ä»¶ç›‘å¬å™¨å’Œåˆå§‹åŒ– ---

            initGame(); // Initialize game

            // Listen for CSS transform animation end event
            // ç›‘å¬ CSS å˜æ¢åŠ¨ç”»ç»“æŸäº‹ä»¶
            canvas.addEventListener('transitionend', (event) => {
                if (event.propertyName === 'transform') isAnimatingZoom = false;
            });

            // Touch event listeners (mobile)
            // è§¦æ‘¸äº‹ä»¶ç›‘å¬å™¨ï¼ˆç§»åŠ¨ç«¯ï¼‰
            canvas.addEventListener('touchstart', (e) => {
                if (IS_MOBILE) { e.preventDefault(); isGestureActive = true; resetIdleTimer(); } // Reset timer
                if (e.touches.length === 1) { // Single finger drag
                    isDragging = true;
                    lastPanX = e.touches[0].clientX; lastPanY = e.touches[0].clientY;
                    initialTouchX = e.touches[0].clientX; initialTouchY = e.touches[0].clientY;
                } else if (e.touches.length === 2) { // Two-finger pinch zoom
                    isDragging = false;
                    initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    initialPinchScale = scale;
                    const rect = canvas.getBoundingClientRect();
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const initialScaleFactor = parseFloat(canvas.dataset.initialScale);
                    initialPinchMidX = (midpoint.x - rect.left) / (scale * initialScaleFactor);
                    initialPinchMidY = (midpoint.y - rect.top) / (scale * initialScaleFactor);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (IS_MOBILE) { e.preventDefault(); isGestureActive = true; resetIdleTimer(); } // Reset timer
                if (e.touches.length === 1 && isDragging) { // Single finger drag
                    translateX += (e.touches[0].clientX - lastPanX);
                    translateY += (e.touches[0].clientY - lastPanY);
                    lastPanX = e.touches[0].clientX; lastPanY = e.touches[0].clientY;
                    clampPan(); applyTransform();
                } else if (e.touches.length === 2) { // Two-finger pinch zoom
                    const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    let newScale = initialPinchScale * (currentPinchDistance / initialPinchDistance);
                    newScale = Math.max(1.0, Math.min(newScale, 2.5)); // Limit zoom range
                    const rect = canvas.getBoundingClientRect();
                    const currentMidpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const initialScaleFactor = parseFloat(canvas.dataset.initialScale);
                    translateX = currentMidpoint.x - rect.left - (initialPinchMidX * newScale * initialScaleFactor);
                    translateY = currentMidpoint.y - rect.top - (initialPinchMidY * newScale * initialScaleFactor);
                    scale = newScale;
                    clampPan(); applyTransform();
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                isDragging = false; initialPinchDistance = 0;
                clampPan(); applyTransform();
                if (e.changedTouches.length === 1 && e.touches.length === 0) { // Single finger tap (place piece)
                    const releasedTouch = e.changedTouches[0];
                    const moveDistance = Math.sqrt(Math.pow(releasedTouch.clientX - initialTouchX, 2) + Math.pow(releasedTouch.clientY - initialTouchY, 2));
                    if (moveDistance < tapThreshold) { // If move distance is less than threshold, consider it a tap
                        const rect = canvas.getBoundingClientRect();
                        const initialScaleFactor = parseFloat(canvas.dataset.initialScale);
                        const logicalCanvasX = (releasedTouch.clientX - rect.left) / (scale * initialScaleFactor);
                        const logicalCanvasY = (releasedTouch.clientY - rect.top) / (scale * initialScaleFactor);
                        const x = Math.round((logicalCanvasX - INTERNAL_DRAWING_BOARD_PADDING) / INTERNAL_DRAWING_CELL_SIZE);
                        const y = Math.round((logicalCanvasY - INTERNAL_DRAWING_BOARD_PADDING) / INTERNAL_DRAWING_CELL_SIZE);
                        if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) handlePlayerMove(x, y);
                    }
                }
                resetIdleTimer(); isGestureActive = false;
            });

            // Mouse event listeners (desktop)
            // é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ï¼ˆæ¡Œé¢ç«¯ï¼‰
            canvas.addEventListener('mousedown', (e) => {
                if (!IS_MOBILE) {
                    isDragging = true; isGestureActive = true;
                    lastPanX = e.clientX; lastPanY = e.clientY;
                    initialTouchX = e.clientX; initialTouchY = e.clientY;
                }
                resetIdleTimer(); // Reset timer
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!IS_MOBILE) {
                    isDragging = false;
                    const moveDistance = Math.sqrt(Math.pow(e.clientX - initialTouchX, 2) + Math.pow(e.clientY - initialTouchY, 2));
                    if (moveDistance < tapThreshold) { // If move distance is less than threshold, consider it a click
                        const rect = canvas.getBoundingClientRect();
                        const initialScaleFactor = parseFloat(canvas.dataset.initialScale);
                        const logicalCanvasX = (e.clientX - rect.left) / (scale * initialScaleFactor);
                        const logicalCanvasY = (e.clientY - rect.top) / (scale * initialScaleFactor);
                        const x = Math.round((logicalCanvasX - INTERNAL_DRAWING_BOARD_PADDING) / INTERNAL_DRAWING_CELL_SIZE);
                        const y = Math.round((logicalCanvasY - INTERNAL_DRAWING_BOARD_PADDING) / INTERNAL_DRAWING_CELL_SIZE);
                        if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) handlePlayerMove(x, y);
                    }
                    isGestureActive = false;
                }
                resetIdleTimer(); // Reset timer
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!IS_MOBILE && e.buttons === 1 && isDragging) { // Mouse left button held down and dragging
                    translateX += (e.clientX - lastPanX);
                    translateY += (e.clientY - lastPanY);
                    lastPanX = e.clientX; lastPanY = e.clientY;
                    clampPan(); applyTransform();
                    isGestureActive = true;
                }
                resetIdleTimer(); // Reset timer
            });

            canvas.addEventListener('mouseout', () => { if (!IS_MOBILE) { isDragging = false; isGestureActive = false; } });

            // Add global event listeners to reset idle timer
            // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬å™¨ä»¥é‡ç½®ç©ºé—²è®¡æ—¶å™¨
            document.addEventListener('mousemove', resetIdleTimer);
            document.addEventListener('keydown', resetIdleTimer);
            document.addEventListener('click', resetIdleTimer);
            document.addEventListener('scroll', resetIdleTimer); // Also reset on scroll

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    calculateResponsiveDisplaySize();
                    drawStaticBoard(); updatePiecesCanvas(); drawBoard();
                    resetIdleTimer(); // Reset timer
                }, 150);
            });
            
            newGameBtn.addEventListener('click', startNewGame);
            
            undoBtn.addEventListener('click', () => {
                if (gameOver || isAiThinking) {
                    logMessage(isAiThinking ? 'AIæ­£åœ¨æ€è€ƒï¼Œæ— æ³•æ‚”æ£‹ã€‚' : 'æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•æ‚”æ£‹ã€‚');
                    return;
                }
                if (gameMode === 1 && undoChances <= 0) { logMessage('æ‚”æ£‹æœºä¼šä¸è¶³ï¼Œè¯·å°è¯•å…‘æ¢ã€‚'); return; }
                if (gameMode === 3) { logMessage('AI vs AI æ¨¡å¼ä¸‹æ— æ³•æ‚”æ£‹ã€‚'); return; }
                if (moveHistory.length === 0) { logMessage('æ£‹ç›˜ä¸Šæ²¡æœ‰å¯æ‚”çš„æ£‹å­ã€‚'); return; }
                
                const undoCount = gameMode === 1 ? Math.min(2, moveHistory.length) : 1; // Undo two steps in Player vs AI mode, one step in other modes
                // ç©å®¶ vs AI æ¨¡å¼æ‚”ä¸¤æ­¥ï¼Œå…¶ä»–æ¨¡å¼æ‚”ä¸€æ­¥
                if (gameMode === 1) undoChances--;
                
                for (let i = 0; i < undoCount; i++) {
                    if (moveHistory.length > 0) {
                        const lastMove = moveHistory.pop();
                        gameBoard[lastMove.x][lastMove.y] = 0;
                        currentPlayer = lastMove.player; 
                    }
                }
                
                lastMovePosition = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                gameOver = false;
                
                updatePiecesCanvas(); drawBoard();
                updateGameStatus(); updateUndoChancesDisplay();
                logMessage(`æ‚”æ£‹ ${undoCount} æ­¥`);
                updateDynamicZoom(); resetIdleTimer(); // Reset timer
            });
            
            difficultyToggle.addEventListener('click', () => {
                difficulty = (difficulty % 3) + 1;
                const difficultyLevels = ['ç®€å•', 'ä¸­ç­‰', 'å›°éš¾'];
                const winRates = ['è¾ƒä½', 'ä¸­ç­‰', 'è¾ƒé«˜']; 
                difficultyText.textContent = `${difficultyLevels[difficulty - 1]}(èƒœç‡${winRates[difficulty - 1]})`;
                logMessage(`æ¸¸æˆéš¾åº¦å·²åˆ‡æ¢è‡³ ${difficultyLevels[difficulty - 1]} (å¼€å…ƒèƒœç‡${winRates[difficulty - 1]})`);
                resetIdleTimer(); // Reset timer
            });
            
            modeToggle.addEventListener('click', () => {
                gameMode = (gameMode % 3) + 1;
                const modeNames = ['ç©å®¶ vs å¼€å…ƒ', 'ç©å®¶ vs ç©å®¶', 'å¼€å…ƒ vs Kaiyuan'];
                modeText.textContent = modeNames[gameMode - 1];
                playerStartsWithBlack = true; gameCount = 1;
                logMessage(`æ¸¸æˆæ¨¡å¼å·²åˆ‡æ¢è‡³ ${modeNames[gameMode - 1]}`);
                initGame(); // initGame will call resetIdleTimer
            });
            
            closeModalBtn.addEventListener('click', () => {
                winnerModal.style.display = 'none';
                startNewGame(); // startNewGame will call initGame, which in turn calls resetIdleTimer
            });
            
            window.addEventListener('click', (event) => {
                if (event.target === winnerModal) {
                    winnerModal.style.display = 'none';
                    startNewGame(); // startNewGame will call initGame, which in turn calls resetIdleTimer
                }
            });

            redeemCodeInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') handleRedeemCode(); 
                resetIdleTimer(); // Reset timer
            });
            redeemCodeInput.addEventListener('input', () => {
                const value = redeemCodeInput.value.trim();
                if (value.length === 7 && /^[a-zA-Z0-9\u4e00-\u9fa5]+$/.test(value)) handleRedeemCode();
                resetIdleTimer(); // Reset timer
            });
            
            musicToggle.addEventListener('click', () => {
                if (music.paused) {
                    music.play().catch(() => logMessage('éŸ³ä¹æ’­æ”¾å¤±è´¥'));
                    musicText.textContent = 'æ’­æ”¾';
                } else {
                    music.pause();
                    musicText.textContent = 'æš‚åœ';
                }
                resetIdleTimer(); // Reset timer
            });
        });
    </script>
</body>
</html>
