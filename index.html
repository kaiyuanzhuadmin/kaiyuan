<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹å¯¹å¼ˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='%238B5A2B'><circle cx='50' cy='50' r='40' fill='white' stroke='%238B5A2B' stroke-width='4'/><circle cx='50' cy='50' r='10' fill='%238B5A2B'/></svg>" type="image/svg+xml">
    
    <!-- æ‰€æœ‰CSSæ ·å¼éƒ½ç›´æ¥å†…è”åœ¨æ­¤å¤„ï¼Œæ¨¡æ‹ŸTailwindçš„å®ç”¨ç±» -->
    <style>
        /* å®šä¹‰CSSå˜é‡ï¼Œç”¨äºæ£‹å­é¢œè‰²ï¼Œä»¥ä¾¿åœ¨JavaScriptä¸­åŠ¨æ€è·å– */
        :root {
            --player: #000000; /* é»˜è®¤ç©å®¶1 (é»‘æ£‹) */
            --opponent: #FFFFFF; /* é»˜è®¤ç©å®¶2/AI (ç™½æ£‹) */
            --primary: #8B5A2B;
            --secondary: #D2B48C;
            --accent: #FF69B4;
            --board: #DEB887;
            --highlight: #FF69B4;
        }

        /* åŸºç¡€æ ·å¼å’Œé¢œè‰²å®šä¹‰ */
        .bg-gradient-to-br { background-image: linear-gradient(to bottom right, var(--amber-50), var(--orange-100)); }
        .from-amber-50 { --amber-50: #fffdfa; }
        .to-orange-100 { --orange-100: #fff9f2; }
        .min-h-screen { min-height: 100vh; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .p-4 { padding: 1rem; }
        .font-sans { font-family: 'Inter', 'system-ui', 'sans-serif'; }
        .max-w-4xl { max-width: 56rem; /* 896px */ }
        .w-full { width: 100%; }
        .mx-auto { margin-left: auto; margin-right: auto; }
        .bg-white { background-color: #ffffff; }
        .rounded-xl { border-radius: 0.75rem; /* 12px */ }
        .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        .overflow-hidden { overflow: hidden; }

        /* Header æ ·å¼ */
        .bg-primary { background-color: var(--primary); }
        .text-white { color: #ffffff; }
        .text-center { text-align: center; }
        .text-clamp-1 { font-size: clamp(1.8rem, 5vw, 2.5rem); } /* text-[clamp(1.8rem,5vw,2.5rem)] */
        .font-bold { font-weight: 700; }
        .tracking-wide { letter-spacing: 0.025em; }
        .mt-2 { margin-top: 0.5rem; }
        .text-secondary-90 { color: rgba(var(--secondary), 0.9); } /* text-secondary/90 */
        .text-clamp-2 { font-size: clamp(1rem, 2vw, 1.2rem); } /* text-[clamp(1rem,2vw,1.2rem)] */

        /* Main åŒºåŸŸæ ·å¼ */
        .p-6 { padding: 1.5rem; }
        .gap-8 { gap: 2rem; }
        .md\:p-8 { /* media query for md:p-8 */ }
        .md\:flex-row { /* media query for md:flex-row */ }
        .md\:gap-8 { /* media query for md:gap-8 */ }

        /* ä¿¡æ¯å’Œæ§åˆ¶åŒºæ ·å¼ */
        .md\:w-1\/4 { /* media query for md:w-1/4 */ }
        .gap-6 { gap: 1.5rem; }
        .bg-gray-50 { background-color: #f9fafb; }
        .rounded-lg { border-radius: 0.5rem; /* 8px */ }
        .shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .text-xl { font-size: 1.25rem; /* 20px */ }
        .text-gray-800 { color: #1f2937; }
        .mb-4 { margin-bottom: 1rem; }
        .mr-2 { margin-right: 0.5rem; }
        .space-y-4 > *:not([hidden]) ~ *:not([hidden]) { margin-top: 1rem; } /* space-y-4 */
        .text-gray-600 { color: #4b5563; }
        .text-sm { font-size: 0.875rem; /* 14px */ }
        .mt-1 { margin-top: 0.25rem; }
        .w-5 { width: 1.25rem; }
        .h-5 { height: 1.25rem; }
        .rounded-full { border-radius: 9999px; }
        .bg-player { background-color: var(--player); }
        .border-2 { border-width: 2px; }
        .border-gray-300 { border-color: #d1d5db; }
        .piece-shadow { box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .font-medium { font-weight: 500; }
        .hidden { display: none; }
        .space-y-3 > *:not([hidden]) ~ *:not([hidden]) { margin-top: 0.75rem; } /* space-y-3 */
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .text-gray-700 { color: #374151; }
        .transition-all { transition-property: all; }
        .duration-300 { transition-duration: 300ms; }
        .hover\:bg-primary-90:hover { background-color: rgba(var(--primary), 0.9); } /* hover:bg-primary/90 */
        .bg-gray-200 { background-color: #e5e7eb; }
        .hover\:bg-gray-300:hover { background-color: #d1d5db; } /* hover:bg-gray-300 */
        .space-y-2 > *:not([hidden]) ~ *:not([hidden]) { margin-top: 0.5rem; } /* space-y-2 */
        .items-start { align-items: flex-start; }
        .italic { font-style: italic; }

        /* æ£‹ç›˜åŒºåŸŸæ ·å¼ */
        .md\:w-3\/4 { /* media query for md:w-3/4 */ }
        .relative { position: relative; }
        .board-shadow { box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15); }
        .bg-board { background-color: var(--board); }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .bg-black-40 { background-color: rgba(0, 0, 0, 0.4); } /* bg-black/40 */
        .mb-3 { margin-bottom: 0.75rem; }
        .w-3 { width: 0.75rem; }
        .h-3 { height: 0.75rem; }
        .mx-1 { margin-left: 0.25rem; margin-right: 0.25rem; }
        .thinking-indicator { animation: thinking 1.5s infinite; }
        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .mt-6 { margin-top: 1.5rem; }
        .h-32 { height: 8rem; }
        .overflow-y-auto { overflow-y: auto; }

        /* Footer æ ·å¼ */
        .bg-gray-800 { background-color: #1f2937; }

        /* æ¨¡æ€æ¡†æ ·å¼ */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 300px;
            border-radius: 8px;
            text-align: center;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* åª’ä½“æŸ¥è¯¢ - æ¨¡æ‹Ÿ Tailwind çš„ md æ–­ç‚¹ */
        @media (min-width: 768px) {
            .md\:p-8 { padding: 2rem; }
            .md\:flex-row { flex-direction: row; }
            .md\:gap-8 { gap: 2rem; }
            .md\:w-1\/4 { width: 25%; }
            .md\:w-3\/4 { width: 75%; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-amber-50 to-orange-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">
    <div class="max-w-4xl w-full mx-auto bg-white rounded-xl shadow-xl overflow-hidden">
        <!-- æ¸¸æˆæ ‡é¢˜ -->
        <header class="bg-primary text-white p-6 text-center">
            <h1 class="text-clamp-1 font-bold tracking-wide">äº”å­æ£‹å¯¹å¼ˆ</h1>
            <p class="mt-2 text-secondary-90 text-clamp-2">æ¥åœºæŒ‘æˆ˜ï¼Œçœ‹è°èƒ½å…ˆè¿æˆäº”å­/â€¢á·…â€¢á·„\à­­~   </p>
        </header>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <main class="p-6 md:p-8 flex flex-col md:flex-row gap-8">
            <!-- æ¸¸æˆä¿¡æ¯å’Œæ§åˆ¶åŒº -->
            <div class="w-full md:w-1/4 flex flex-col gap-6">
                <div class="bg-gray-50 p-5 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="mr-2">â„¹ï¸</span>æ¸¸æˆä¿¡æ¯
                    </h2>
                    <div class="space-y-4">
                        <div>
                            <p class="text-gray-600 text-sm">å½“å‰å›åˆ</p>
                            <div id="current-player" class="flex items-center mt-1">
                                <div id="player-indicator" class="w-5 h-5 rounded-full bg-player border-2 border-gray-300 mr-2 piece-shadow"></div>
                                <span id="player-text" class="font-medium">ç©å®¶</span>
                            </div>
                        </div>
                        <div>
                            <p class="text-gray-600 text-sm">æ¸¸æˆçŠ¶æ€</p>
                            <p id="game-status" class="mt-1 font-medium text-gray-800">æ¸¸æˆè¿›è¡Œä¸­</p>
                        </div>
                        <div id="winner-info" class="hidden">
                            <p class="text-gray-600 text-sm">è·èƒœæ–¹</p>
                            <div class="mt-1 flex items-center">
                                <div id="winner-indicator" class="w-5 h-5 rounded-full mr-2 piece-shadow"></div>
                                <span id="winner-text" class="font-medium"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-50 p-5 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="mr-2">âš™ï¸</span>æ¸¸æˆæ§åˆ¶
                    </h2>
                    <div class="space-y-3">
                        <button id="new-game" class="w-full bg-primary hover:bg-primary-90 text-white py-2 px-4 rounded-lg transition-all duration-300 flex items-center justify-center">
                            <span class="mr-2">ğŸ”„</span>æ–°æ¸¸æˆ
                        </button>
                        <button id="undo" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 px-4 rounded-lg transition-all duration-300 flex items-center justify-center">
                            <span class="mr-2">â†©ï¸</span>æ‚”æ£‹
                        </button>
                        <button id="mode-toggle" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 px-4 rounded-lg transition-all duration-300 flex items-center justify-center">
                            <span class="mr-2">ğŸ‘¥</span>æ¨¡å¼: <span id="mode-text">ç©å®¶ vs å¼€å…ƒ</span>
                        </button>
                        <button id="music-toggle" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 px-4 rounded-lg transition-all duration-300 flex items-center justify-center">
                            <span class="mr-2" id="music-icon">ğŸµ</span>éŸ³ä¹: <span id="music-text">æš‚åœ</span>
                        </button>
                    </div>
                </div>

                <div class="bg-gray-50 p-5 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="mr-2">ğŸ’¡</span>æ¸¸æˆè§„åˆ™
                    </h2>
                    <ul class="text-gray-700 space-y-2 text-sm">
                        <li class="flex items-start">
                            <span class="mr-2">âœ…</span>
                            <span>é»‘æ£‹å…ˆä¸‹ï¼Œç™½æ£‹åä¸‹</span>
                        </li>
                        <li class="flex items-start">
                            <span class="mr-2">âœ…</span>
                            <span>å…ˆåœ¨æ¨ªã€ç«–æˆ–æ–œæ–¹å‘è¿æˆäº”å­è€…è·èƒœ</span>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- æ£‹ç›˜åŒºåŸŸ -->
            <div class="w-full md:w-3/4 flex flex-col items-center">
                <div class="relative">
                    <div id="board-container" class="board-shadow rounded-lg overflow-hidden relative">
                        <canvas id="board" class="bg-board"></canvas>
                        <div id="thinking" class="absolute inset-0 bg-black-40 flex items-center justify-center hidden">
                            <div class="bg-white p-6 rounded-lg text-center">
                                <div class="flex justify-center mb-3">
                                    <div class="w-3 h-3 rounded-full bg-primary mx-1 thinking-indicator"></div>
                                    <div class="w-3 h-3 rounded-full bg-primary mx-1 thinking-indicator" style="animation-delay: 0.3s"></div>
                                    <div class="w-3 h-3 rounded-full bg-primary mx-1 thinking-indicator" style="animation-delay: 0.6s"></div>
                                </div>
                                <p class="text-primary font-bold">å¼€å…ƒæ­£åœ¨æ€è€ƒ...</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-6 w-full">
                    <div class="bg-gray-50 p-4 rounded-lg shadow-md">
                        <h3 class="font-bold text-gray-800 mb-2">æ¸¸æˆæ—¥å¿—</h3>
                        <div id="game-log" class="h-32 overflow-y-auto text-sm text-gray-700 space-y-1">
                            <p class="text-gray-500 italic">æ¸¸æˆå¼€å§‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- é¡µè„š -->
        <footer class="bg-gray-800 text-white p-4 text-center text-sm">
            <p>äº”å­æ£‹æ¸¸æˆ &copy; 2025 | Designed by å¼€å…ƒ </p>
        </footer>
    </div>

    <!-- èƒœåˆ©æç¤ºæ¨¡æ€æ¡† -->
    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="winner-modal-title">èƒœåˆ©æç¤º</h2>
            <p id="winner-modal-message"></p>
        </div>
    </div>

    <!-- æ·»åŠ éŸ³é¢‘å…ƒç´  -->
    <audio id="music" src="jasmine_flower.mp3" loop></audio>

    <!-- AI Worker Script -->
    <script id="ai-worker" type="javascript/worker">
        // AI Worker: Minimax with Alpha-Beta Pruning
        self.onmessage = function(e) {
            const { board, aiPlayer, searchDepth } = e.data;
            const bestMove = findBestMove(board, aiPlayer, searchDepth);
            self.postMessage(bestMove);
        };

        const WIN_SCORE = 10000000;

        // Heuristic evaluation function scoring patterns
        const SCORE_PATTERNS = {
            FIVE: WIN_SCORE,
            LIVE_FOUR: 100000,
            DEAD_FOUR: 10000,
            LIVE_THREE: 1000,
            DEAD_THREE: 100,
            LIVE_TWO: 100,
            DEAD_TWO: 10,
            LIVE_ONE: 10,
            DEAD_ONE: 1,
        };
        
        // Finds the best move for the AI player using minimax
        function findBestMove(board, aiPlayer, searchDepth) {
            let bestScore = -Infinity;
            let move = null;
            const moves = getPossibleMoves(board);

            for (const [r, c] of moves) {
                board[r][c] = aiPlayer;
                let score = minimax(board, searchDepth - 1, -Infinity, Infinity, false, aiPlayer);
                board[r][c] = 0; // Undo the move
                if (score > bestScore) {
                    bestScore = score;
                    move = { r, c };
                }
            }
            // If no good move is found (e.g., at the start), choose a random central point
            if (!move && moves.length > 0) {
                move = moves[Math.floor(Math.random() * moves.length)];
            } else if (!move) {
                const center = Math.floor(board.length / 2);
                move = { r: center, c: center };
            }
            return move;
        }

        // Minimax algorithm with Alpha-Beta Pruning
        function minimax(board, depth, alpha, beta, isMaximizing, aiPlayer) {
            let score = evaluateBoard(board, aiPlayer);

            if (Math.abs(score) >= WIN_SCORE || depth === 0) {
                return score;
            }

            const humanPlayer = aiPlayer === 1 ? 2 : 1;
            const moves = getPossibleMoves(board);

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const [r, c] of moves) {
                    board[r][c] = aiPlayer;
                    let newEval = minimax(board, depth - 1, alpha, beta, false, aiPlayer);
                    board[r][c] = 0;
                    maxEval = Math.max(maxEval, newEval);
                    alpha = Math.max(alpha, newEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return maxEval;
            } else { // Minimizing
                let minEval = Infinity;
                for (const [r, c] of moves) {
                    board[r][c] = humanPlayer;
                    let newEval = minimax(board, depth - 1, alpha, beta, true, aiPlayer);
                    board[r][c] = 0;
                    minEval = Math.min(minEval, newEval);
                    beta = Math.min(beta, newEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return minEval;
            }
        }
        
        // Gets possible moves, prioritizing positions around existing pieces
        function getPossibleMoves(board) {
            const moves = [];
            const size = board.length;
            const hasMove = new Set();

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c] === 0) {
                        // Prioritize positions around existing pieces
                        if (hasNeighbor(board, r, c, size)) {
                            moves.push([r, c]);
                        }
                    }
                }
            }
            // If no pieces on board, return center point
            if (moves.length === 0) {
                 const center = Math.floor(size / 2);
                 if(board[center][center] === 0) moves.push([center, center]);
            }
            return moves;
        }
        
        // Checks if a position has a neighbor piece
        function hasNeighbor(board, r, c, size) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newR = r + i;
                    const newC = c + j;
                    if (newR >= 0 && newR < size && newC >= 0 && newC < size && board[newR][newC] !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Evaluates the entire board for a given AI player
        function evaluateBoard(board, aiPlayer) {
            let totalScore = 0;
            const humanPlayer = aiPlayer === 1 ? 2 : 1;
            totalScore += calculateScoreForPlayer(board, aiPlayer, aiPlayer);
            totalScore -= calculateScoreForPlayer(board, humanPlayer, aiPlayer) * 1.2; // Give higher weight to opponent's threats
            return totalScore;
        }

        // Calculates the score for a specific player on the board
        function calculateScoreForPlayer(board, player, aiPlayer) {
            let score = 0;
            const size = board.length;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c] === player) {
                        directions.forEach(([dr, dc]) => {
                            score += evaluateDirection(board, r, c, dr, dc, player);
                        });
                    }
                }
            }
            return score;
        }
        
        // Evaluates a line in a specific direction from a starting point
        function evaluateDirection(board, r, c, dr, dc, player) {
            const line = [];
            // Look 4 steps ahead
            for (let i = 0; i < 5; i++) {
                const newR = r + i * dr;
                const newC = c + i * dc;
                if (newR >= 0 && newR < board.length && newC >= 0 && newC < board.length) {
                    line.push(board[newR][newC]);
                } else {
                    line.push(-1); // Boundary
                }
            }
            
            // Check previous position to avoid duplicate calculations
            const prevR = r - dr;
            const prevC = c - dc;
            if (prevR >= 0 && prevR < board.length && prevC >= 0 && prevC < board.length && board[prevR][prevC] === player) {
                return 0;
            }

            return getLineScore(line, player);
        }
        
        // Gets the score for a given line segment
        function getLineScore(line, player) {
            let count = 0;
            let openEnds = 0;
            let opponent = player === 1 ? 2 : 1;

            // Count player's pieces
            for(let i = 0; i < 5; i++) {
                if(line[i] === player) count++;
                else if (line[i] === opponent) { // If opponent's piece, this line is blocked
                    return 0;
                }
            }

            if (count === 5) return SCORE_PATTERNS.FIVE;

            // Simplified scoring logic
            if (count === 4) {
                // Assuming "dead four" for simplicity
                return SCORE_PATTERNS.DEAD_FOUR;
            }
            if (count === 3) {
                 return SCORE_PATTERNS.LIVE_THREE; // Simplified
            }
            if (count === 2) {
                 return SCORE_PATTERNS.LIVE_TWO; // Simplified
            }
            if (count === 1) {
                 return SCORE_PATTERNS.LIVE_ONE;
            }
            
            return 0;
        }

    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing game.");
            // Game constants
            const BOARD_SIZE = 15; // 15x15 board
            const CELL_SIZE = 40; // Size of each cell (pixels)
            const PIECE_SIZE = CELL_SIZE * 0.8; // Piece size
            const BOARD_PADDING = CELL_SIZE; // Board padding
            const AI_SEARCH_DEPTH = 2; // AI search depth, can be adjusted for difficulty and response time
            
            // Game state
            let gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0)); // 0:empty, 1:player, 2:AI/player2
            let currentPlayer = 1; // 1:player, 2:AI/player2
            let gameOver = false;
            let moveHistory = []; // Records move history
            let lastMovePosition = null; // Records the last move's position
            let gameMode = 1; // 1: Player vs AI, 2: Player vs Player
            let gameCount = 0; // Tracks the number of games played to alternate starting player/colors

            let aiWorker; // AI Worker instance
            
            // DOM elements
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const boardContainer = document.getElementById('board-container');
            const currentPlayerIndicator = document.getElementById('player-indicator');
            const currentPlayerText = document.getElementById('player-text');
            const gameStatus = document.getElementById('game-status');
            const winnerInfo = document.getElementById('winner-info');
            const winnerIndicator = document.getElementById('winner-indicator');
            const winnerText = document.getElementById('winner-text'); 
            const newGameBtn = document.getElementById('new-game');
            const undoBtn = document.getElementById('undo');
            const gameLog = document.getElementById('game-log');
            const thinkingIndicator = document.getElementById('thinking');
            const modeToggle = document.getElementById('mode-toggle');
            const modeText = document.getElementById('mode-text');
            const winnerModal = document.getElementById('winner-modal');
            const winnerModalTitle = document.getElementById('winner-modal-title');
            const winnerModalMessage = document.getElementById('winner-modal-message');
            const closeModalBtn = document.querySelector('.close');
            // Music related elements
            const music = document.getElementById('music');
            const musicToggle = document.getElementById('music-toggle');
            const musicText = document.getElementById('music-text');
            const musicIcon = document.getElementById('music-icon'); // Get the music icon element

            // Set Canvas size
            function setCanvasSize() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2; // Adjust canvas size to fit pieces at boundaries
                canvas.width = size;
                canvas.height = size;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
                boardContainer.style.width = `${size}px`;
                boardContainer.style.height = `${size}px`;
            }
            
            // Initialize game
            function initGame() {
                console.log("initGame called. Initial currentPlayer:", currentPlayer, "gameMode:", gameMode);
                // Initialize AI Worker if not already done
                if (!aiWorker) {
                    try {
                        const workerScript = document.getElementById('ai-worker').textContent;
                        const blob = new Blob([workerScript], { type: 'application/javascript' });
                        aiWorker = new Worker(URL.createObjectURL(blob));
                        aiWorker.onmessage = (e) => {
                            handleAIMove(e.data);
                        };
                    } catch (error) {
                        console.error("Failed to create AI Worker:", error);
                        showWinnerModal("Error", "æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWeb Workerï¼ŒAIæ— æ³•è¿è¡Œã€‚");
                    }
                }

                setCanvasSize();
                gameBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
                gameOver = false;
                moveHistory = [];
                lastMovePosition = null;
                
                gameCount++; // Increment game count for each new game

                // Determine starting player and colors based on gameCount
                if (gameCount % 2 === 1) { // Odd game count: Player 1 (black) goes first
                    currentPlayer = 1;
                    // Player 1 is black, Player 2/AI is white
                    document.documentElement.style.setProperty('--player', '#000000');
                    document.documentElement.style.setProperty('--opponent', '#FFFFFF');
                } else { // Even game count: Player 2/AI (black) goes first
                    currentPlayer = 2;
                    // Player 1 is white, Player 2/AI is black
                    document.documentElement.style.setProperty('--player', '#FFFFFF');
                    document.documentElement.style.setProperty('--opponent', '#000000');
                }

                drawBoard(); // Draw board with new piece colors
                
                // Update UI
                updateGameStatus();
                clearGameLog();
                logMessage('æ¸¸æˆå¼€å§‹ï¼Œè¯·ç‚¹å‡»æ£‹ç›˜è½å­');
                winnerModal.style.display = 'none';

                // If AI is player 2 and it's AI's turn to start
                if (gameMode === 1 && currentPlayer === 2) {
                    console.log("initGame: AI is starting the game.");
                    thinkingIndicator.classList.remove('hidden');
                    if (aiWorker) {
                        setTimeout(() => {
                            aiWorker.postMessage({
                                board: JSON.parse(JSON.stringify(gameBoard)),
                                aiPlayer: 2,
                                searchDepth: AI_SEARCH_DEPTH
                            });
                        }, 500);
                    }
                }
            }
            
            // Draw the board
            function drawBoard() {
                const size = (BOARD_SIZE - 1) * CELL_SIZE + BOARD_PADDING * 2;
                ctx.clearRect(0, 0, size, size);
                
                // Draw board background
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board').trim();
                ctx.fillRect(0, 0, size, size);
                
                // Draw grid lines
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                
                // Draw horizontal and vertical lines
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.lineTo(size - BOARD_PADDING, BOARD_PADDING + i * CELL_SIZE);
                    ctx.stroke();
                    
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(BOARD_PADDING + i * CELL_SIZE, BOARD_PADDING);
                    ctx.lineTo(BOARD_PADDING + i * CELL_SIZE, size - BOARD_PADDING);
                    ctx.stroke();
                }
                
                // Draw star points
                const starPoints = [
                    {r: 3, c: 3}, {r: 3, c: 11}, 
                    {r: 7, c: 7}, // Center point
                    {r: 11, c: 3}, {r: 11, c: 11}
                ];
                
                starPoints.forEach(point => {
                    drawStarPoint(point.r, point.c);
                });
                
                // Draw all pieces
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (gameBoard[r][c] === 1) {
                            drawPiece(r, c, 'player'); // Use 'player' color from CSS variable
                        } else if (gameBoard[r][c] === 2) {
                            drawPiece(r, c, 'opponent'); // Use 'opponent' color from CSS variable
                        }
                    }
                }
                
                // Draw marker for the last move
                if (lastMovePosition) {
                    drawLastMoveMarker(lastMovePosition.r, lastMovePosition.c);
                }
            }
            
            // Draw star point
            function drawStarPoint(r, c) {
                const centerX = BOARD_PADDING + c * CELL_SIZE;
                const centerY = BOARD_PADDING + r * CELL_SIZE;
                const radius = 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#8B4513';
                ctx.fill();
            }
            
            // Draw piece
            function drawPiece(r, c, colorType) { // Changed color to colorType to use CSS variables
                const centerX = BOARD_PADDING + c * CELL_SIZE;
                const centerY = BOARD_PADDING + r * CELL_SIZE;
                
                // Get actual color from CSS variables
                const pieceColor = getComputedStyle(document.documentElement).getPropertyValue(`--${colorType}`).trim();

                // Draw shadow
                ctx.beginPath();
                ctx.arc(centerX + 2, centerY + 2, PIECE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fill();
                
                // Draw piece
                ctx.beginPath();
                ctx.arc(centerX, centerY, PIECE_SIZE / 2, 0, 2 * Math.PI);
                
                // Create radial gradient
                const gradient = ctx.createRadialGradient(
                    centerX - PIECE_SIZE / 5, centerY - PIECE_SIZE / 5, PIECE_SIZE / 10,
                    centerX, centerY, PIECE_SIZE / 2
                );
                
                if (pieceColor === '#FFFFFF' || pieceColor === '#FFF') { // White piece
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(1, '#E6E6E6');
                    ctx.strokeStyle = '#D9D9D9';
                } else { // Black piece
                    gradient.addColorStop(0, '#404040');
                    gradient.addColorStop(1, '#000000');
                    ctx.strokeStyle = '#333333';
                }
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw marker for the last move
            function drawLastMoveMarker(r, c) {
                const centerX = BOARD_PADDING + c * CELL_SIZE;
                const centerY = BOARD_PADDING + r * CELL_SIZE;
                const radius = PIECE_SIZE / 4;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim(); // Use bright pink as marker color
                ctx.fill();
            }
            
            // Check if any player wins
            function checkWin(r, c, player) {
                const directions = [
                    { dr: 1, dc: 0 },  // Vertical
                    { dr: 0, dc: 1 },  // Horizontal
                    { dr: 1, dc: 1 },  // Diagonal (top-left to bottom-right)
                    { dr: 1, dc: -1 }  // Diagonal (top-right to bottom-left)
                ];

                for (const { dr, dc } of directions) {
                    let count = 1; // Current position already has one piece
                    
                    // Check in one direction
                    for (let i = 1; i < 5; i++) {
                        const newR = r + i * dr;
                        const newC = c + i * dc;
                        if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && gameBoard[newR][newC] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    // Check in the opposite direction
                    for (let i = 1; i < 5; i++) {
                        const newR = r - i * dr;
                        const newC = c - i * dc;
                        if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && gameBoard[newR][newC] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    // Exactly five in a row, no overline (simplified)
                    if (count === 5) {
                        return true;
                    }
                }
                return false;
            }
            
            // Check if the board is full
            function isBoardFull() {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (gameBoard[r][c] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // Handle player's move
            function handlePlayerMove(r, c) {
                console.log("handlePlayerMove: Entry. currentPlayer:", currentPlayer, "gameMode:", gameMode, "gameOver:", gameOver);
                if (gameOver) {
                    console.log("handlePlayerMove: Game over. Returning.");
                    return;
                }
                if (gameBoard[r][c] !== 0) {
                    console.log("handlePlayerMove: Cell already occupied. Returning.");
                    return;
                }
                
                // Record the move
                gameBoard[r][c] = currentPlayer;
                moveHistory.push({r, c, player: currentPlayer});
                lastMovePosition = {r, c};
                
                // Update UI
                drawBoard();
                logMessage(`ç©å®¶${currentPlayer}åœ¨(${r+1},${c+1})è½å­`);
                
                // Check if player wins
                if (checkWin(r, c, currentPlayer)) {
                    gameOver = true;
                    const winnerMessage = currentPlayer === 1 ? 'ç©å®¶1è·èƒœï¼' : (gameMode === 1 ? 'å¼€å…ƒè·èƒœï¼' : 'ç©å®¶2è·èƒœï¼');
                    updateGameStatus(winnerMessage);
                    logMessage(`æ­å–œï¼Œ${winnerMessage}`);
                    showWinnerModal(winnerMessage);
                    return;
                }
                
                // Check if board is full
                if (isBoardFull()) {
                    gameOver = true;
                    updateGameStatus('å¹³å±€ï¼');
                    logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                    showWinnerModal('å¹³å±€ï¼');
                    return;
                }
                
                // Switch player
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateGameStatus();
                console.log("handlePlayerMove: After player move, new currentPlayer:", currentPlayer);

                if (gameMode === 1 && currentPlayer === 2) {
                    console.log("handlePlayerMove: It's AI's turn, triggering AI.");
                    // Show AI thinking indicator
                    thinkingIndicator.classList.remove('hidden');
                    
                    // Trigger AI move
                    if (aiWorker) { // Ensure worker is initialized
                        setTimeout(() => {
                            aiWorker.postMessage({
                                board: JSON.parse(JSON.stringify(gameBoard)), // Deep copy
                                aiPlayer: 2, // AI is always player 2 (white)
                                searchDepth: AI_SEARCH_DEPTH
                            });
                        }, 500); // Add a small delay for AI to "think"
                    } else {
                        console.error("AI Worker not initialized. Cannot trigger AI.");
                        logMessage("AI Workeræœªåˆå§‹åŒ–ï¼Œæ— æ³•è§¦å‘AIã€‚");
                        // Fallback to next player or end game if AI is crucial
                        currentPlayer = 1; // Revert to player's turn
                        updateGameStatus();
                    }
                }
            }

            // Handle AI's move
            function handleAIMove(move) {
                console.log("handleAIMove: Entry. currentPlayer:", currentPlayer, "gameMode:", gameMode);
                thinkingIndicator.classList.add('hidden'); // Hide thinking indicator
                if (move && gameBoard[move.r][move.c] === 0) {
                    // Record AI's move
                    gameBoard[move.r][move.c] = 2; // AI is player 2
                    moveHistory.push({r: move.r, c: move.c, player: 2});
                    lastMovePosition = {r: move.r, c: move.c};
                    
                    // Update UI
                    drawBoard();
                    logMessage(`å¼€å…ƒåœ¨(${move.r+1},${move.c+1})è½å­`);
                    
                    // Check if AI wins
                    if (checkWin(move.r, move.c, 2)) {
                        gameOver = true;
                        updateGameStatus('å¼€å…ƒè·èƒœï¼');
                        logMessage('å¼€å…ƒèµ¢äº†ï¼Œå†è¯•ä¸€æ¬¡å§ï¼');
                        showWinnerModal('å¼€å…ƒè·èƒœï¼');
                        return; // Game over, stop here
                    }
                    
                    // Check if board is full
                    if (isBoardFull()) {
                        gameOver = true;
                        updateGameStatus('å¹³å±€ï¼');
                        logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                        showWinnerModal('å¹³å±€ï¼');
                        return; // Game over, stop here
                    }
                    
                    // Switch to player's turn
                    currentPlayer = 1; 
                    updateGameStatus();
                    console.log("handleAIMove: After AI move, new currentPlayer:", currentPlayer);
                } else {
                    console.log("handleAIMove: AI returned invalid move or no valid moves.");
                    // If AI returns an invalid move, find a random valid one as fallback
                    let validMove = findRandomValidMove();
                    if(validMove) {
                        gameBoard[validMove.r][validMove.c] = 2;
                        moveHistory.push({r: validMove.r, c: validMove.c, player: 2});
                        lastMovePosition = {r: validMove.r, c: validMove.c};
                        drawBoard();
                        logMessage(`å¼€å…ƒåœ¨(${validMove.r+1},${validMove.c+1})è½å­ (Fallback)`);
                        if (checkWin(validMove.r, validMove.c, 2)) {
                            gameOver = true;
                            updateGameStatus('å¼€å…ƒè·èƒœï¼');
                            logMessage('å¼€å…ƒèµ¢äº†ï¼Œå†è¯•ä¸€æ¬¡å§ï¼');
                            showWinnerModal('å¼€å…ƒè·èƒœï¼');
                            return;
                        }
                        if (isBoardFull()) {
                            gameOver = true;
                            updateGameStatus('å¹³å±€ï¼');
                            logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                            showWinnerModal('å¹³å±€ï¼');
                            return;
                        }
                        currentPlayer = 1; 
                        updateGameStatus();
                        console.log("handleAIMove: After AI fallback move, new currentPlayer:", currentPlayer);
                    } else {
                         gameOver = true;
                         updateGameStatus('å¹³å±€ï¼'); // No valid moves left
                         logMessage('æ¸¸æˆç»“æŸï¼Œå¹³å±€ï¼');
                         showWinnerModal('å¹³å±€ï¼');
                         console.log("handleAIMove: No valid moves for AI, declaring draw.");
                    }
                }
            }
            
            // Finds a random valid move as a fallback
            function findRandomValidMove() {
                const emptySpots = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (gameBoard[r][c] === 0) {
                            emptySpots.push({r, c});
                        }
                    }
                }
                if (emptySpots.length > 0) {
                    return emptySpots[Math.floor(Math.random() * emptySpots.length)];
                }
                return null;
            }
            
            // Update game status UI
            function updateGameStatus(message) {
                if (message) {
                    gameStatus.textContent = message;
                    winnerInfo.classList.remove('hidden');
                    
                    // Determine winner indicator color based on current player's piece color
                    const player1Color = getComputedStyle(document.documentElement).getPropertyValue('--player').trim();
                    const player2Color = getComputedStyle(document.documentElement).getPropertyValue('--opponent').trim();

                    if (message.includes('ç©å®¶1')) {
                        winnerIndicator.style.backgroundColor = player1Color;
                        winnerText.textContent = 'ç©å®¶1';
                    } else if (message.includes('ç©å®¶2')) {
                        winnerIndicator.style.backgroundColor = player2Color;
                        winnerText.textContent = 'ç©å®¶2';
                    } else if (message.includes('å¼€å…ƒ')) {
                        winnerIndicator.style.backgroundColor = player2Color;
                        winnerText.textContent = 'å¼€å…ƒ';
                    } else {
                        winnerInfo.classList.add('hidden');
                    }
                } else {
                    gameStatus.textContent = 'æ¸¸æˆè¿›è¡Œä¸­';
                    winnerInfo.classList.add('hidden');
                    
                    // Determine current player indicator color based on their piece color
                    const player1Color = getComputedStyle(document.documentElement).getPropertyValue('--player').trim();
                    const player2Color = getComputedStyle(document.documentElement).getPropertyValue('--opponent').trim();

                    if (currentPlayer === 1) {
                        currentPlayerIndicator.style.backgroundColor = player1Color;
                        currentPlayerText.textContent = 'ç©å®¶1';
                    } else {
                        currentPlayerIndicator.style.backgroundColor = player2Color;
                        currentPlayerText.textContent = gameMode === 1 ? 'å¼€å…ƒ' : 'ç©å®¶2';
                    }
                }
            }

            // Music play/pause function
            musicToggle.addEventListener('click', () => {
                if (music.paused) {
                    music.play();
                    musicIcon.textContent = 'ğŸµ'; // Change icon to playing
                    musicText.textContent = 'æ’­æ”¾';
                } else {
                    music.pause();
                    musicIcon.textContent = 'ğŸ”‡'; // Change icon to muted
                    musicText.textContent = 'æš‚åœ';
                }
            });

            // Initialize game
            initGame();

            // Handle board click event
            canvas.addEventListener('click', (event) => {
                if (gameOver || (gameMode === 1 && currentPlayer === 2)) {
                    // If game is over or it's AI's turn in PvE mode, do nothing
                    console.log("Canvas click ignored: gameOver or AI's turn.");
                    return;
                }

                const rect = canvas.getBoundingClientRect();
                const x = Math.round((event.clientX - rect.left - BOARD_PADDING) / CELL_SIZE);
                const y = Math.round((event.clientY - rect.top - BOARD_PADDING) / CELL_SIZE);

                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                    handlePlayerMove(y, x); // Note: Swapped x, y to r, c for consistency (row, column)
                }
            });

            // New game button event
            newGameBtn.addEventListener('click', () => {
                initGame(); // Starts a new game, which now handles color/turn swapping
            });

            // Undo button event
            undoBtn.addEventListener('click', () => {
                console.log("Undo clicked. Before undo: currentPlayer:", currentPlayer, "moveHistory length:", moveHistory.length);
                if (gameOver) { // Cannot undo if game is already over
                    logMessage("æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•æ‚”æ£‹ã€‚");
                    return;
                }
                if (moveHistory.length === 0) {
                    logMessage("æ²¡æœ‰å¯æ‚”çš„æ£‹æ­¥ã€‚");
                    return;
                }

                if (gameMode === 1) { // Player vs AI mode
                    // If the last move was by AI, undo both AI's move and the player's move before it
                    if (moveHistory[moveHistory.length - 1].player === 2) {
                        const aiMove = moveHistory.pop();
                        gameBoard[aiMove.r][aiMove.c] = 0;
                        logMessage(`æ’¤é”€å¼€å…ƒåœ¨(${aiMove.r + 1},${aiMove.c + 1})çš„è½å­`);
                        
                        if (moveHistory.length > 0 && moveHistory[moveHistory.length - 1].player === 1) {
                            const playerMove = moveHistory.pop();
                            gameBoard[playerMove.r][playerMove.c] = 0;
                            logMessage(`æ’¤é”€ç©å®¶åœ¨(${playerMove.r + 1},${playerMove.c + 1})çš„è½å­`);
                        }
                        currentPlayer = 1; // Always return to player's turn after undoing AI's move
                    } else if (moveHistory[moveHistory.length - 1].player === 1) {
                        // If the last move was by player (and AI hasn't moved yet)
                        const playerMove = moveHistory.pop();
                        gameBoard[playerMove.r][playerMove.c] = 0;
                        logMessage(`æ’¤é”€ç©å®¶åœ¨(${playerMove.r + 1},${playerMove.c + 1})çš„è½å­`);
                        currentPlayer = 1; // It's still player's turn
                    }
                } else { // Player vs Player mode
                    const lastMove = moveHistory.pop();
                    gameBoard[lastMove.r][lastMove.c] = 0;
                    currentPlayer = lastMove.player === 1 ? 2 : 1; // Switch back to the player whose turn it was
                    logMessage(`æ’¤é”€ç©å®¶${lastMove.player}åœ¨(${lastMove.r + 1},${lastMove.c + 1})çš„è½å­`);
                }
                
                lastMovePosition = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                drawBoard();
                updateGameStatus();
                console.log("After undo: currentPlayer:", currentPlayer, "moveHistory length:", moveHistory.length);
            });

            // Mode toggle button event
            modeToggle.addEventListener('click', () => {
                gameMode = gameMode === 1 ? 2 : 1;
                const modeNames = ['ç©å®¶ vs å¼€å…ƒ', 'ç©å®¶ vs ç©å®¶'];
                modeText.textContent = modeNames[gameMode - 1];
                logMessage(`æ¸¸æˆæ¨¡å¼å·²åˆ‡æ¢è‡³ ${modeNames[gameMode - 1]}`);
                initGame(); // Restart game with new mode
            });

            // Close modal button event
            closeModalBtn.addEventListener('click', () => {
                winnerModal.style.display = 'none';
            });

            // Game log recording
            function logMessage(message) {
                const logEntry = document.createElement('p');
                logEntry.textContent = message;
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            // Clear game log
            function clearGameLog() {
                gameLog.innerHTML = '';
            }

            // Display winner modal
            function showWinnerModal(title, message) {
                winnerModalTitle.textContent = title;
                winnerModalMessage.textContent = message;
                winnerModal.style.display = 'block';
            }
        });
    </script>
</body>
</html>
